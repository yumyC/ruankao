# 算法策略总结

本文总结了四大经典算法策略：分治法、贪心法、动态规划、回溯法。包含文字特点、代码特点、经典例子、时间复杂度与空间复杂度，附表格和流程步骤，便于复习和快速查阅。

---

## 一、分治法（Divide and Conquer）

**文字特点：**  
- 将大问题分成两份或多份小问题，分别解决后再合并  
- 常用词汇：分、合并、递归、拆分、合成  

**代码特点：**  
- 一定会用递归（方法自己调用自己）  
- 每次调用自己去处理小规模问题，直到触底返回  

**经典例子：**  
- 二分查找：在有序数组中，每次只处理中间的一半  
- 归并排序：将小数组合并成大数组  
- 斐波拉契数列递归求值  

**流程示例（斐波拉契数列）：**  
    def fib(n):
        if n == 0 or n == 1:
            return n
        return fib(n-1) + fib(n-2)

**时间复杂度：** O(log n) 或 O(n log n)（视具体算法而定）

---

## 二、贪心法（Greedy）

**文字特点：**  
- 每一步选择当前最优，不考虑整体是否最优  
- 常用词汇：局部最优、选择策略、当前最优  

**代码特点：**  
- 逻辑简单，按规则逐步选择  
- 不一定用递归或数组  

**经典例子与流程：**

1. **部分背包问题（fractional knapsack）：**  
   - 按单位价值排序  
   - 依次放入背包，必要时拆分物品  
   - 可得到最优解  

    背包容量：70  
    物品信息：
        物品一：容量20，总价值140 → 单位价值7  
        物品二：容量30，总价值180 → 单位价值6  
        物品三：容量50，总价值250 → 单位价值5  

    装入流程：
        放入物品一：20  
        放入物品二：30  
        剩余容量20，放入物品三部分20  

    总价值 = 140 + 180 + 100 = 420（最优）

2. **活动安排问题（场地安排）：**  
   - 将活动按开始时间排序（快速排序 → 分治法）  
   - 对每个活动，选择当前可用场地（贪心法）  
   - 计算最小场地数  

**时间复杂度：**  
- 排序：O(N log N)  
- 分配场地：O(N × M)（两层循环）

---

## 三、动态规划（Dynamic Programming）

**文字特点：**  
- 问题具有 **最优子结构**（optimal substructure）  
- 有 **重复子问题**（overlapping subproblems）  
- 常出现关键词：求最优解、最小值、最大值  

**代码特点：**  
- **自顶向下**：递归 + 记忆化  
- **自底向上**：迭代 + 数组存储  

**经典例子：**  
- 斐波拉契数列  
- 矩阵链乘法优化  
- 0-1 背包问题  

**示例流程（矩阵链乘法）：**  
    给定矩阵 A1, A2, …, An，求最少乘法次数  
    初始化二维数组 M[n][n]  
    for length in 2..n:
        for i in 0..n-length:
            j = i + length - 1
            M[i][j] = min(M[i][k] + M[k+1][j] + cost(Ai..Ak, Ak+1..Aj)) for k in i..j-1

**时间复杂度：** O(N^A)（A 为循环层数）  
**空间复杂度：** O(N) 或 O(N^2)（视数组维度而定）

---

## 四、回溯法（Backtracking）

**文字特点：**  
- 如果当前路径不通，返回上一步（backtrack）继续尝试其他可能  
- 常用词汇：回溯、尝试、选择、撤销  

**代码特点：**  
- 当前选择合法 → 往下递归（加一）  
- 当前选择不合法 → 返回上一步（减一）  

**经典例子：**  
- N 皇后问题  
- 图的深度优先搜索（DFS）  
- 子集/排列组合问题  

**流程示例（N 皇后问题）：**  
    def solve(row):
        if row == N:
            保存解
            return
        for col in 0..N-1:
            if 可以放置皇后:
                放置皇后
                solve(row+1)
                撤销皇后

---

## 四大策略对比表

| 算法策略 | 文字特点 | 代码特点 | 经典例子 | 时间复杂度 | 空间复杂度 |
|-----------|----------|-----------|----------|------------|------------|
| 分治法 | 分/合并，拆分小问题 | 递归调用自身 | 二分查找、归并排序、斐波拉契 | O(log n) ~ O(n log n) | 递归栈 O(log n) |
| 贪心法 | 局部最优，不关注整体 | 按规则选择，不一定递归 | 部分背包、活动安排、最小生成树 | O(N log N) + O(N×M) | O(N) 或 O(1) |
| 动态规划 | 最优子结构，重复子问题 | 自顶向下递归或自底向上数组 | 斐波拉契、矩阵链乘法、0-1 背包 | O(N^A) | O(N) 或 O(N^2) |
| 回溯法 | 尝试 + 回退 | 加一/减一，递归 DFS | N 皇后、子集、排列组合 | 最坏 O(N!) | O(N) 递归栈 |

---

## 总结记忆技巧

1. **分治法** → 拆小问题，递归合并，触底返回  
2. **贪心法** → 当前最优，局部选择，不关注整体最优  
3. **动态规划** → 最优子结构 + 重复子问题；数组存储或递归记忆化  
4. **回溯法** → 尝试 + 回退，DFS 风格
