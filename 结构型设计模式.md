# 结构型设计模式学习笔记

本文总结了**结构型设计模式的七种**核心内容，包括特点、适用场景、关键点、示例和复习技巧，方便快速理解与回顾。

---

## 目录

1. [结构型设计模式概览](#结构型设计模式概览)
2. [适配器模式（Adapter）](#适配器模式adapter)
3. [桥接模式（Bridge）](#桥接模式bridge)
4. [组合模式（Composite）](#组合模式composite)
5. [装饰模式（Decorator）](#装饰模式decorator)
6. [外观模式（Facade）](#外观模式facade)
7. [享元模式（Flyweight）](#享元模式flyweight)
8. [代理模式（Proxy）](#代理模式proxy)
9. [复习技巧与口诀](#复习技巧与口诀)

---

## 结构型设计模式概览

| 模式 | 英文 | 特点 | 适用场景 | 关键点 |
|------|------|------|----------|--------|
| 适配器 | Adapter | 转换接口，使不兼容接口协同工作 | 第三方接口与客户端不匹配 | 类适配器、对象适配器 |
| 桥接 | Bridge | 抽象部分与实现部分分离 | 抽象和实现独立变化 | 通过接口桥接实现部分 |
| 组合 | Composite | 将对象组合成树形结构 | 对象有层级关系（文件系统） | 一致性处理单个和组合对象 |
| 装饰 | Decorator | 动态给对象添加职责 | 灵活组合功能，避免子类爆炸 | 继承同一个接口，可叠加装饰 |
| 外观 | Facade | 提供统一接口简化子系统使用 | 系统接口复杂 | 对外提供统一入口 |
| 享元 | Flyweight | 共享对象以减少内存 | 对象数量巨大，可共享 | 内部状态与外部状态分离 |
| 代理 | Proxy | 为对象提供代理以控制访问 | 安全、隐私、远程控制 | 代理与真实对象继承同一接口 |

---

## 适配器模式（Adapter）

**生活例子**：笔记本电脑需要 22V 直流电，家用电源是 220V 交流电，需要电源适配器。

**流程**：

1. 第三方调用者调用父类接口。
2. 实际开发人员提供具体类实现，可能方法名不同。
3. 使用适配器类，将具体类方法映射到调用者需要的方法。
4. 调用者不需改变原有代码，适配器桥接两者。

**示例 Python**：

    class Target:
        def request(self):
            pass

    class Adaptee:
        def specific_request(self):
            print("具体方法执行")

    class Adapter(Target):
        def __init__(self, adaptee):
            self.adaptee = adaptee
        def request(self):
            self.adaptee.specific_request()

    client = Adapter(Adaptee())
    client.request()  # 输出: 具体方法执行

**总结**：将一个接口转换成客户希望的接口，使原本不兼容的接口协同工作。

---

## 桥接模式（Bridge）

**特点**：

- 将抽象部分（主体）与实现部分（功能）分离
- 抽象和实现可以独立变化

**流程示意**：

1. 抽象部分定义接口。
2. 具体抽象（具体型号）继承抽象部分。
3. 实现部分定义接口。
4. 具体实现（功能模块）实现接口。
5. 抽象部分通过接口桥接实现部分。

**示例 Python**：

    class Implementor:
        def operation_impl(self):
            pass

    class ConcreteImplementorA(Implementor):
        def operation_impl(self):
            print("功能A")

    class Abstraction:
        def __init__(self, implementor):
            self.implementor = implementor
        def operation(self):
            self.implementor.operation_impl()

    class RefinedAbstraction(Abstraction):
        pass

    abstraction = RefinedAbstraction(ConcreteImplementorA())
    abstraction.operation()  # 输出: 功能A

**总结**：抽象与实现独立变化，通过桥接接口结合使用。

---

## 组合模式（Composite）

**特点**：

- 对象有层级关系，可组合成树形结构
- 用户对单个对象和组合对象的操作一致

**例子**：文件管理系统，文件夹和文件共用组件接口。

**示例 Python**：

    class Component:
        def operation(self):
            pass

    class Leaf(Component):
        def operation(self):
            print("文件操作")

    class Composite(Component):
        def __init__(self):
            self.children = []
        def add(self, component):
            self.children.append(component)
        def remove(self, component):
            self.children.remove(component)
        def operation(self):
            for child in self.children:
                child.operation()

    file1 = Leaf()
    folder = Composite()
    folder.add(file1)
    folder.operation()  # 输出: 文件操作

**总结**：整体-部分层次结构，一致性处理单个和组合对象。

---

## 装饰模式（Decorator）

**特点**：

- 动态给对象添加职责
- 灵活组合功能，避免子类爆炸

**例子**：炒饭+鸡蛋+香肠+酸菜

**示例 Python**：

    class Component:
        def operation(self):
            pass

    class FriedRice(Component):
        def operation(self):
            print("炒饭")

    class Decorator(Component):
        def __init__(self, component):
            self.component = component
        def operation(self):
            self.component.operation()

    class EggDecorator(Decorator):
        def operation(self):
            super().operation()
            print("加鸡蛋")

    rice = FriedRice()
    rice_with_egg = EggDecorator(rice)
    rice_with_egg.operation()
    # 输出:
    # 炒饭
    # 加鸡蛋

**总结**：动态叠加功能，不增加子类数量，灵活调整功能顺序和数量。

---

## 外观模式（Facade）

**特点**：

- 提供统一接口，简化子系统使用
- 调用者无需了解内部复杂实现

**示例 Python**：

    class SubsystemA:
        def operation_a(self):
            print("子系统A操作")

    class SubsystemB:
        def operation_b(self):
            print("子系统B操作")

    class Facade:
        def __init__(self):
            self.a = SubsystemA()
            self.b = SubsystemB()
        def operation(self):
            self.a.operation_a()
            self.b.operation_b()

    client = Facade()
    client.operation()
    # 输出:
    # 子系统A操作
    # 子系统B操作

**总结**：简化系统接口，对外提供统一入口。

---

## 享元模式（Flyweight）

**特点**：

- 共享对象以减少内存
- 内部状态与外部状态分离

**例子**：扑克游戏，仅需四个对象表示四种花色，通过数字组合生成 52 张牌。

**示例 Python**：

    class Card:
        def __init__(self, suit):
            self.suit = suit  # 内部状态

    class CardFactory:
        _cards = {}
        @staticmethod
        def get_card(suit):
            if suit not in CardFactory._cards:
                CardFactory._cards[suit] = Card(suit)
            return CardFactory._cards[suit]

    heart = CardFactory.get_card("红桃")
    print(heart.suit)  # 输出: 红桃

**总结**：共享对象，降低内存占用，实现轻量级设计。

---

## 代理模式（Proxy）

**特点**：

- 为对象提供代理以控制访问
- 代理和真实对象继承同一接口

**例子**：律师代理两方谈判

**示例 Python**：

    class Subject:
        def request(self):
            pass

    class RealSubject(Subject):
        def request(self):
            print("真实请求执行")

    class Proxy(Subject):
        def __init__(self, real_subject):
            self.real_subject = real_subject
        def request(self):
            # 可添加访问控制
            self.real_subject.request()

    proxy = Proxy(RealSubject())
    proxy.request()  # 输出: 真实请求执行

**总结**：通过代理隔离对象，增加安全性、隐私和访问控制。

---

## 复习技巧与口诀

- 七种结构型模式口诀：**“四条组装外响外箱袋”**
  - 适配器（Adapter）  
  - 桥接（Bridge）  
  - 组合（Composite）  
  - 装饰（Decorator）  
  - 外观（Facade）  
  - 享元（Flyweight）  
  - 代理（Proxy）  
- 理解优先于死记：
  1. 看模式解决的问题
  2. 结合 UML 图理解结构
  3. 复习对应示例代码

> 本文整理自课堂讲解，含表格、流程与 Python 示例，便于快速复习和理解结构型设计模式。
