# 软件工程详细知识点

## 软件生命周期模型详解

### 1. 瀑布模型 (Waterfall Model)
**阶段划分**
1. 需求分析 → 2. 系统设计 → 3. 详细设计 → 4. 编码实现 → 5. 测试 → 6. 维护

**特点**
- 线性顺序执行，前一阶段完成后才能进入下一阶段
- 每个阶段都有明确的输入输出和里程碑
- 文档驱动，每个阶段都要产生相应文档

**适用场景**
- 需求明确且稳定的项目
- 技术成熟，风险较小的项目
- 对文档要求严格的项目

**优缺点**
- 优点：结构清晰，便于管理，质量有保证
- 缺点：缺乏灵活性，风险发现较晚，用户参与度低

### 2. 螺旋模型 (Spiral Model)
**四个象限**
1. **制定计划**：确定目标、选择方案、约束条件
2. **风险分析**：识别风险、分析风险、解决风险
3. **实施工程**：开发和验证下一级产品
4. **客户评估**：评价开发工作，规划下一轮

**特点**
- 风险驱动的过程模型
- 迭代开发，每次迭代都包含四个象限
- 适合大型复杂项目

### 3. 增量模型 (Incremental Model)
**特点**
- 将软件分解为多个增量
- 每个增量都是一个可工作的软件版本
- 逐步增加功能

### 4. 敏捷开发模型
**核心价值观**
- 个体和互动 胜过 流程和工具
- 工作的软件 胜过 详尽的文档
- 客户合作 胜过 合同谈判
- 响应变化 胜过 遵循计划

**常见方法**
- **Scrum**：Sprint、Product Backlog、Sprint Backlog
- **极限编程(XP)**：结对编程、测试驱动开发、持续集成
- **看板(Kanban)**：可视化工作流、限制在制品

## 需求工程

### 需求分类
**功能需求**
- 系统必须提供的功能和服务
- 用户与系统的交互
- 系统对特定输入的反应

**非功能需求**
- **性能需求**：响应时间、吞吐量、资源利用率
- **可靠性需求**：故障率、恢复时间、可用性
- **安全性需求**：访问控制、数据保护、审计
- **可用性需求**：易学性、易用性、用户满意度

### 需求获取技术
1. **访谈**：结构化访谈、非结构化访谈
2. **问卷调查**：大范围收集需求信息
3. **观察**：实地观察用户工作流程
4. **文档分析**：分析现有系统文档
5. **原型法**：快速构建原型验证需求
6. **头脑风暴**：集体讨论产生创意

### 需求分析方法
**结构化分析**
- 数据流图(DFD)：描述数据在系统中的流动
- 数据字典：定义数据流、数据存储、处理的详细信息
- 加工说明：描述处理逻辑的详细规格

**面向对象分析**
- 用例建模：识别参与者和用例
- 领域建模：识别概念类和关系
- 行为建模：描述对象的动态行为

## 软件设计

### 设计原则
**模块化设计原则**
1. **单一职责原则(SRP)**：一个模块只负责一个功能
2. **开闭原则(OCP)**：对扩展开放，对修改关闭
3. **里氏替换原则(LSP)**：子类可以替换父类
4. **接口隔离原则(ISP)**：不应强迫客户依赖不需要的接口
5. **依赖倒置原则(DIP)**：依赖抽象而不是具体实现

**模块设计质量度量**
- **耦合度**：模块间相互依赖的程度（越低越好）
  - 数据耦合 < 标记耦合 < 控制耦合 < 公共耦合 < 内容耦合
- **内聚度**：模块内部元素结合的紧密程度（越高越好）
  - 功能内聚 > 顺序内聚 > 通信内聚 > 过程内聚 > 时间内聚 > 逻辑内聚 > 偶然内聚

### 架构设计模式
**分层架构**
- 表示层：用户界面
- 业务逻辑层：业务规则和处理
- 数据访问层：数据存储和检索

**MVC模式**
- Model：数据和业务逻辑
- View：用户界面
- Controller：控制逻辑

**微服务架构**
- 服务独立部署
- 通过API通信
- 数据库分离

## 软件测试详解

### 测试策略
**V模型**
- 需求分析 ↔ 验收测试
- 概要设计 ↔ 系统测试
- 详细设计 ↔ 集成测试
- 编码 ↔ 单元测试

### 黑盒测试方法
**等价类划分**
```
示例：年龄输入(1-120)
有效等价类：[1,120]
无效等价类：(<1), (>120), (非数字)
```

**边界值分析**
```
示例：年龄输入(1-120)
测试用例：0, 1, 2, 119, 120, 121
```

**判定表测试**
```
条件：用户类型(VIP/普通), 购买金额(>1000/<1000)
动作：折扣率
规则1：VIP + >1000 → 20%折扣
规则2：VIP + <1000 → 10%折扣
规则3：普通 + >1000 → 5%折扣
规则4：普通 + <1000 → 无折扣
```

### 白盒测试方法
**控制流测试**
- **语句覆盖**：每个语句至少执行一次
- **判定覆盖**：每个判定的真假分支都要执行
- **条件覆盖**：每个条件的真假值都要取到
- **路径覆盖**：每条可能的执行路径都要测试

**数据流测试**
- 定义-使用路径测试
- 变量的定义和使用关系

## 软件质量保证

### 质量模型
**McCall质量模型**
- **产品运行**：正确性、可靠性、效率、完整性、可用性
- **产品修改**：可维护性、灵活性、可测试性
- **产品转移**：可移植性、可重用性、互操作性

**ISO/IEC 25010质量模型**
1. **功能适合性**：功能完整性、功能正确性、功能适宜性
2. **性能效率**：时间特性、资源利用性、容量
3. **兼容性**：共存性、互操作性
4. **易用性**：可识别性、易学性、易操作性、用户错误防护性、用户界面美观性、可访问性
5. **可靠性**：成熟性、可用性、容错性、易恢复性
6. **安全性**：保密性、完整性、不可否认性、可问责性、真实性
7. **可维护性**：模块化、可重用性、可分析性、可修改性、可测试性
8. **可移植性**：适应性、易安装性、易替换性

### 软件度量
**规模度量**
- **代码行数(LOC)**：源代码行数
- **功能点(FP)**：基于功能复杂度的度量

**复杂度度量**
- **圈复杂度**：程序控制流的复杂程度
- **Halstead复杂度**：基于操作符和操作数的复杂度

**质量度量**
- **缺陷密度**：每千行代码的缺陷数
- **测试覆盖率**：测试用例覆盖的代码比例

## 配置管理

### 配置项识别
**配置项类型**
- 源代码文件
- 可执行文件
- 文档（需求、设计、测试）
- 数据文件
- 工具和环境

### 版本控制
**版本号规则**
- 主版本号.次版本号.修订号
- 例：2.1.3

**分支策略**
- **主分支(master/main)**：稳定版本
- **开发分支(develop)**：开发版本
- **特性分支(feature)**：新功能开发
- **发布分支(release)**：发布准备
- **热修复分支(hotfix)**：紧急修复

### 变更控制
**变更控制流程**
1. 变更请求提交
2. 变更影响分析
3. 变更评审和批准
4. 变更实施
5. 变更验证
6. 变更关闭

## 项目管理要点

### 项目计划技术
**工作分解结构(WBS)**
- 将项目分解为可管理的工作包
- 分解原则：100%规则、相互独立、适当粒度

**网络图技术**
**关键路径法(CPM)**
- 最早开始时间(ES)
- 最早完成时间(EF)
- 最晚开始时间(LS)
- 最晚完成时间(LF)
- 总浮动时间 = LS - ES = LF - EF

**计划评审技术(PERT)**
- 乐观时间(a)
- 最可能时间(m)
- 悲观时间(b)
- 期望时间 = (a + 4m + b) / 6

### 风险管理
**风险识别技术**
- 头脑风暴
- 德尔菲技术
- 检查表
- 假设分析

**风险分析**
- **定性分析**：概率-影响矩阵
- **定量分析**：期望货币价值、敏感性分析

**风险应对策略**
- **威胁应对**：规避、转移、减轻、接受
- **机会应对**：开拓、分享、提高、接受

### 成本管理
**成本估算方法**
- **类比估算**：基于历史项目数据
- **参数估算**：基于统计模型
- **自下而上估算**：详细估算各工作包

**挣值管理**
- **计划价值(PV)**：计划完成工作的预算成本
- **挣值(EV)**：已完成工作的预算成本
- **实际成本(AC)**：已完成工作的实际成本
- **成本偏差(CV)** = EV - AC
- **进度偏差(SV)** = EV - PV
- **成本绩效指数(CPI)** = EV / AC
- **进度绩效指数(SPI)** = EV / PV