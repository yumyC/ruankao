# 数据库技术详解

## 数据库基础理论

### 数据模型
**层次模型**
- 结构：树形结构，每个节点只有一个父节点
- 优点：结构简单，查询效率高
- 缺点：不能表示多对多关系，数据冗余

**网状模型**
- 结构：图形结构，节点可以有多个父节点
- 优点：能表示复杂关系，减少数据冗余
- 缺点：结构复杂，不易理解和维护

**关系模型**
- 结构：二维表格，行为记录，列为属性
- 优点：结构简单，理论基础扎实，易于理解
- 缺点：查询效率相对较低

### 关系模型基本概念

#### 基本术语
- **关系(Relation)**：一个二维表
- **元组(Tuple)**：表中的一行，表示一个实体
- **属性(Attribute)**：表中的一列，表示实体的特征
- **域(Domain)**：属性的取值范围
- **分量**：元组中的一个属性值
- **关系模式**：关系的结构描述

#### 键的概念
**超键(Super Key)**
- 定义：能唯一标识元组的属性集合
- 特点：可能包含多余属性

**候选键(Candidate Key)**
- 定义：最小的超键，不能再删除任何属性
- 特点：唯一性、最小性

**主键(Primary Key)**
- 定义：从候选键中选择的一个作为主键
- 特点：唯一、非空、稳定

**外键(Foreign Key)**
- 定义：引用其他关系主键的属性
- 作用：维护参照完整性

**主属性与非主属性**
- 主属性：包含在任何候选键中的属性
- 非主属性：不包含在任何候选键中的属性

## 关系代数

### 基本操作

#### 选择(Selection) σ
**符号**：σ条件(R)
**功能**：从关系R中选择满足条件的元组
**示例**：σ年龄>25(学生) - 选择年龄大于25的学生

#### 投影(Projection) π
**符号**：π属性列表(R)
**功能**：从关系R中选择指定的属性列
**示例**：π姓名,年龄(学生) - 选择学生的姓名和年龄

#### 连接(Join) ⋈
**自然连接**：R ⋈ S
- 在公共属性上相等的元组进行连接
- 结果中公共属性只出现一次

**θ连接**：R ⋈θ S
- 按照θ条件进行连接
- θ可以是=、<、>、≤、≥、≠

**外连接**
- **左外连接**：保留左关系的所有元组
- **右外连接**：保留右关系的所有元组
- **全外连接**：保留两个关系的所有元组

#### 集合操作
**并(Union) ∪**
- R ∪ S：包含R或S中的所有元组
- 要求：R和S具有相同的关系模式

**交(Intersection) ∩**
- R ∩ S：包含既在R中又在S中的元组

**差(Difference) -**
- R - S：包含在R中但不在S中的元组

**笛卡尔积(Cartesian Product) ×**
- R × S：R中每个元组与S中每个元组的组合

#### 除法(Division) ÷
**符号**：R ÷ S
**功能**：找出R中与S中所有元组都有关系的元组
**应用**：查询"选修了所有课程的学生"

## 数据库设计

### ER模型

#### 基本概念
**实体(Entity)**
- 定义：客观存在并可相互区别的事物
- 表示：矩形框
- 类型：强实体、弱实体

**属性(Attribute)**
- 定义：实体的特征或性质
- 表示：椭圆形
- 类型：
  - **简单属性**：不可再分的属性
  - **复合属性**：可以分解为更小部分的属性
  - **单值属性**：对每个实体只有一个值
  - **多值属性**：对每个实体可能有多个值
  - **派生属性**：可以从其他属性计算得出

**联系(Relationship)**
- 定义：实体之间的关联
- 表示：菱形框
- 类型：一对一(1:1)、一对多(1:N)、多对多(M:N)

#### ER图转换为关系模式

**实体转换**
- 每个实体转换为一个关系
- 实体的属性成为关系的属性
- 实体的键成为关系的主键

**联系转换**
- **1:1联系**：可以合并到任一实体关系中
- **1:N联系**：在N端实体关系中加入1端的主键作为外键
- **M:N联系**：单独建立关系，包含两端实体的主键

**多值属性转换**
- 为多值属性单独建立关系
- 包含实体主键和多值属性

### 函数依赖

#### 基本概念
**函数依赖(Functional Dependency)**
- 定义：设R(U)是属性集U上的关系模式，X、Y是U的子集，如果对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖于X
- 记作：X → Y

**完全函数依赖**
- 定义：如果X → Y，且对于X的任何真子集X'，都有X' ↛ Y，则称Y完全函数依赖于X
- 记作：X →f Y

**部分函数依赖**
- 定义：如果X → Y，但Y不完全函数依赖于X，则称Y部分函数依赖于X
- 记作：X →p Y

**传递函数依赖**
- 定义：如果X → Y，Y → Z，且Y ↛ X，则称Z传递函数依赖于X
- 记作：X →t Z

#### 函数依赖的推理规则(Armstrong公理)

**基本规则**
1. **自反律**：如果Y ⊆ X ⊆ U，则X → Y
2. **增广律**：如果X → Y，则XZ → YZ
3. **传递律**：如果X → Y，Y → Z，则X → Z

**导出规则**
4. **合并规则**：如果X → Y，X → Z，则X → YZ
5. **伪传递规则**：如果X → Y，WY → Z，则XW → Z
6. **分解规则**：如果X → YZ，则X → Y，X → Z

### 规范化理论

#### 第一范式(1NF)
**定义**：关系模式R的所有属性都是不可分的基本数据项

**要求**
- 每个属性都是原子的
- 不允许表中表的结构
- 不允许重复组

**示例**
```
违反1NF的表：
学号 | 姓名 | 课程成绩
001  | 张三 | 数学:90,英语:85

符合1NF的表：
学号 | 姓名 | 课程 | 成绩
001  | 张三 | 数学 | 90
001  | 张三 | 英语 | 85
```

#### 第二范式(2NF)
**定义**：关系模式R∈1NF，且每个非主属性完全函数依赖于候选键

**要求**
- 满足1NF
- 消除非主属性对候选键的部分函数依赖

**分解方法**
- 将部分依赖的属性与决定它的部分候选键组成新关系
- 在原关系中删除这些属性

**示例**
```
违反2NF的关系：
学生课程(学号, 课程号, 姓名, 学分, 成绩)
函数依赖：
(学号, 课程号) → 成绩
学号 → 姓名
课程号 → 学分

分解为2NF：
学生(学号, 姓名)
课程(课程号, 学分)
选课(学号, 课程号, 成绩)
```

#### 第三范式(3NF)
**定义**：关系模式R∈2NF，且每个非主属性都不传递依赖于候选键

**要求**
- 满足2NF
- 消除非主属性对候选键的传递函数依赖

**分解方法**
- 将传递依赖的属性与决定它的属性组成新关系
- 在原关系中保留决定属性作为外键

**示例**
```
违反3NF的关系：
学生(学号, 姓名, 系号, 系名)
函数依赖：
学号 → 姓名, 系号
系号 → 系名

分解为3NF：
学生(学号, 姓名, 系号)
系(系号, 系名)
```

#### BCNF(Boyce-Codd范式)
**定义**：关系模式R∈1NF，且对于每个函数依赖X → Y，X都包含候选键

**与3NF的区别**
- 3NF允许主属性对候选键的部分和传递依赖
- BCNF不允许任何属性对候选键的部分和传递依赖

**示例**
```
违反BCNF的关系：
教学(学号, 课程号, 教师)
函数依赖：
(学号, 课程号) → 教师
教师 → 课程号

分解为BCNF：
教师课程(教师, 课程号)
学生教师(学号, 教师)
```

#### 第四范式(4NF)
**多值依赖**
- 定义：设R(U)是属性集U上的关系模式，X、Y、Z是U的子集，且Z=U-X-Y，如果对于R的任意关系r，给定的一对(x,z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关，则称Y多值依赖于X
- 记作：X →→ Y

**第四范式定义**
- 关系模式R∈1NF，且对于每个非平凡多值依赖X →→ Y，X都包含候选键

## SQL语言详解

### 数据定义语言(DDL)

#### 创建表
```sql
CREATE TABLE 表名 (
    列名1 数据类型 [约束],
    列名2 数据类型 [约束],
    ...
    [表级约束]
);

-- 示例
CREATE TABLE Student (
    Sno CHAR(9) PRIMARY KEY,
    Sname CHAR(20) UNIQUE,
    Ssex CHAR(2),
    Sage SMALLINT,
    Sdept CHAR(20)
);
```

#### 修改表结构
```sql
-- 添加列
ALTER TABLE 表名 ADD 列名 数据类型 [约束];

-- 删除列
ALTER TABLE 表名 DROP COLUMN 列名;

-- 修改列
ALTER TABLE 表名 ALTER COLUMN 列名 数据类型;

-- 添加约束
ALTER TABLE 表名 ADD CONSTRAINT 约束名 约束类型;
```

#### 删除表
```sql
DROP TABLE 表名;
```

### 数据操作语言(DML)

#### 插入数据
```sql
-- 插入单行
INSERT INTO 表名 (列1, 列2, ...) VALUES (值1, 值2, ...);

-- 插入多行
INSERT INTO 表名 (列1, 列2, ...) 
VALUES (值1, 值2, ...), (值1, 值2, ...), ...;

-- 从其他表插入
INSERT INTO 表名 (列1, 列2, ...)
SELECT 列1, 列2, ... FROM 其他表 WHERE 条件;
```

#### 更新数据
```sql
UPDATE 表名 
SET 列1 = 值1, 列2 = 值2, ...
WHERE 条件;

-- 示例
UPDATE Student 
SET Sage = Sage + 1 
WHERE Sdept = 'CS';
```

#### 删除数据
```sql
DELETE FROM 表名 WHERE 条件;

-- 示例
DELETE FROM Student WHERE Sno = '201215121';
```

### 数据查询语言(DQL)

#### 基本查询结构
```sql
SELECT [DISTINCT] 列名列表
FROM 表名列表
[WHERE 条件]
[GROUP BY 列名列表 [HAVING 条件]]
[ORDER BY 列名列表 [ASC|DESC]];
```

#### 连接查询

**内连接**
```sql
-- 等值连接
SELECT Student.Sno, Sname, Cname, Grade
FROM Student, SC, Course
WHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno;

-- 使用JOIN语法
SELECT Student.Sno, Sname, Cname, Grade
FROM Student 
JOIN SC ON Student.Sno = SC.Sno
JOIN Course ON SC.Cno = Course.Cno;
```

**外连接**
```sql
-- 左外连接
SELECT Student.Sno, Sname, Cname, Grade
FROM Student 
LEFT JOIN SC ON Student.Sno = SC.Sno
LEFT JOIN Course ON SC.Cno = Course.Cno;

-- 右外连接
SELECT Student.Sno, Sname, Cname, Grade
FROM Student 
RIGHT JOIN SC ON Student.Sno = SC.Sno;

-- 全外连接
SELECT Student.Sno, Sname, Cname, Grade
FROM Student 
FULL OUTER JOIN SC ON Student.Sno = SC.Sno;
```

#### 子查询

**单行子查询**
```sql
SELECT Sno, Sname, Sdept
FROM Student
WHERE Sdept = (
    SELECT Sdept 
    FROM Student 
    WHERE Sname = '刘晨'
);
```

**多行子查询**
```sql
-- 使用IN
SELECT Sno, Sname
FROM Student
WHERE Sno IN (
    SELECT Sno 
    FROM SC 
    WHERE Cno = '2'
);

-- 使用ANY
SELECT Sname, Sage
FROM Student
WHERE Sage < ANY (
    SELECT Sage 
    FROM Student 
    WHERE Sdept = 'CS'
);

-- 使用ALL
SELECT Sname, Sage
FROM Student
WHERE Sage < ALL (
    SELECT Sage 
    FROM Student 
    WHERE Sdept = 'CS'
);
```

**相关子查询**
```sql
SELECT Sno, Sname, Sdept
FROM Student S1
WHERE EXISTS (
    SELECT *
    FROM Student S2
    WHERE S2.Sdept = S1.Sdept AND S2.Sname = '刘晨'
);
```

#### 聚合函数
```sql
-- 基本聚合函数
SELECT COUNT(*) AS 总人数,
       AVG(Sage) AS 平均年龄,
       MAX(Sage) AS 最大年龄,
       MIN(Sage) AS 最小年龄,
       SUM(Grade) AS 总成绩
FROM Student, SC
WHERE Student.Sno = SC.Sno;

-- 分组聚合
SELECT Sdept, COUNT(*) AS 人数, AVG(Sage) AS 平均年龄
FROM Student
GROUP BY Sdept
HAVING COUNT(*) > 5;
```

#### 窗口函数
```sql
-- 排名函数
SELECT Sno, Sname, Grade,
       ROW_NUMBER() OVER (ORDER BY Grade DESC) AS 排名,
       RANK() OVER (ORDER BY Grade DESC) AS 并列排名,
       DENSE_RANK() OVER (ORDER BY Grade DESC) AS 密集排名
FROM SC;

-- 分组排名
SELECT Sno, Cno, Grade,
       ROW_NUMBER() OVER (PARTITION BY Cno ORDER BY Grade DESC) AS 课程内排名
FROM SC;

-- 累计函数
SELECT Sno, Grade,
       SUM(Grade) OVER (ORDER BY Sno) AS 累计成绩,
       AVG(Grade) OVER (ORDER BY Sno ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS 移动平均
FROM SC;
```

### 数据控制语言(DCL)

#### 权限管理
```sql
-- 授权
GRANT 权限列表 ON 对象 TO 用户 [WITH GRANT OPTION];

-- 示例
GRANT SELECT, INSERT ON Student TO U1;
GRANT ALL PRIVILEGES ON Student TO U2 WITH GRANT OPTION;

-- 收回权限
REVOKE 权限列表 ON 对象 FROM 用户 [CASCADE|RESTRICT];

-- 示例
REVOKE SELECT ON Student FROM U1;
```

#### 事务控制
```sql
-- 开始事务
BEGIN TRANSACTION;

-- 提交事务
COMMIT;

-- 回滚事务
ROLLBACK;

-- 设置保存点
SAVEPOINT 保存点名;

-- 回滚到保存点
ROLLBACK TO 保存点名;
```

## 数据库设计过程

### 需求分析阶段
**任务**
- 收集和分析用户需求
- 确定数据库的应用目标
- 定义数据库的边界和约束

**产出**
- 数据字典
- 数据流图
- 需求规格说明书

### 概念设计阶段
**任务**
- 设计概念模型(ER图)
- 独立于具体的DBMS
- 反映用户的信息需求

**步骤**
1. 实体识别
2. 属性识别
3. 联系识别
4. ER图绘制
5. ER图优化

### 逻辑设计阶段
**任务**
- 将ER图转换为关系模式
- 进行规范化处理
- 优化关系模式

**步骤**
1. ER图转换为关系模式
2. 关系模式规范化
3. 模式评价和优化

### 物理设计阶段
**任务**
- 选择具体的DBMS
- 设计物理存储结构
- 设计索引和分区策略

**内容**
- 存储结构设计
- 索引设计
- 分区设计
- 性能优化

### 实施和维护阶段
**任务**
- 创建数据库
- 加载数据
- 应用程序开发
- 数据库维护

## 数据库优化

### 查询优化

#### 索引优化
**索引类型**
- **B+树索引**：适合范围查询和排序
- **哈希索引**：适合等值查询
- **位图索引**：适合低基数列
- **全文索引**：适合文本搜索

**索引设计原则**
- 在经常查询的列上建立索引
- 在连接条件上建立索引
- 避免在经常更新的列上建立索引
- 复合索引的列顺序很重要

#### SQL优化技巧
**查询重写**
```sql
-- 避免SELECT *
-- 不好的写法
SELECT * FROM Student WHERE Sdept = 'CS';

-- 好的写法
SELECT Sno, Sname FROM Student WHERE Sdept = 'CS';

-- 使用EXISTS代替IN
-- 不好的写法
SELECT Sname FROM Student 
WHERE Sno IN (SELECT Sno FROM SC WHERE Cno = '1');

-- 好的写法
SELECT Sname FROM Student S
WHERE EXISTS (SELECT 1 FROM SC WHERE Sno = S.Sno AND Cno = '1');
```

**避免函数操作**
```sql
-- 不好的写法
SELECT * FROM Student WHERE YEAR(入学日期) = 2020;

-- 好的写法
SELECT * FROM Student 
WHERE 入学日期 >= '2020-01-01' AND 入学日期 < '2021-01-01';
```

### 数据库设计优化

#### 反规范化
**适用场景**
- 查询性能要求高
- 数据更新频率低
- 可以接受一定的数据冗余

**常用技术**
- 增加冗余列
- 增加派生列
- 重新组表
- 分割表

#### 分区技术
**水平分区**
- 按行分割表
- 常用分区方式：范围分区、哈希分区、列表分区

**垂直分区**
- 按列分割表
- 将不常用的列分离到单独的表

#### 数据库集群
**主从复制**
- 主库负责写操作
- 从库负责读操作
- 提高读性能和可用性

**分库分表**
- 水平分库：按业务模块分库
- 垂直分库：按数据特征分库
- 分表：将大表拆分为小表