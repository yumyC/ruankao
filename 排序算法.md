# 排序算法概念与分类

## 稳定排序 vs 不稳定排序

- **稳定排序**：相等元素在排序前后的相对顺序不变。
- **不稳定排序**：相等元素在排序前后的相对顺序可能改变。

**技巧**：
- 排序过程中 **相邻元素比较** → 稳定排序
- 排序过程中 **跨区域比较** → 可能不稳定

**示例**：

原数组：`[红21, 蓝21, 13, 76]`  
- 红21在蓝21前 → 稳定  
- 红21在蓝21后 → 不稳定

---

# 排序算法三大类

| 类别 | 示例算法 | 特性 |
|------|---------|------|
| 插入类 | 直接插入排序、希尔排序 | 稳定（插入排序）、分组提升效率（希尔排序） |
| 选择类 | 直接选择排序、堆排序 | 不稳定，堆排序优化时间复杂度 |
| 交换类 | 冒泡排序、快速排序 | 冒泡稳定，快速排序不稳定 |

---

# 插入排序

## 定义
当插入第 **i** 个记录时，前 i-1 个记录已经排好，只需找到第 i 个记录的合适位置插入。

## 示例步骤

原数组：`[68, 59, 52, 57]`

1. 第一个元素 68 不动。
2. 插入第二个元素 59 → 比 68 小 → 插入前面  
   数组：`[59, 68, 52, 57]`
3. 插入第三个元素 52 → 比 59、68 小 → 插入最前  
   数组：`[52, 59, 68, 57]`
4. 插入第四个元素 57 → 比 59 小 → 插入 52 与 59 之间  
   数组：`[52, 57, 59, 68]`

## 总结

| 特性 | 值 |
|------|----|
| 稳定性 | 稳定 |
| 时间复杂度 | O(N²) 平均，O(N) 最优（基本有序） |
| 空间复杂度 | O(1) |

---

# 希尔排序（Shell Sort）

- **升级版插入排序**，采用 **分组+插入** 提高效率。
- **不稳定**，因为存在跨区域比较。

**分组与排序**：
- 初始增量 `gap = N/2` → 对每组进行插入排序
- 逐渐减小增量，最终 `gap = 1` → 全局插入排序

| 特性 | 值 |
|------|----|
| 稳定性 | 不稳定 |
| 时间复杂度 | O(N^1.3) |
| 空间复杂度 | O(1) |

---

# 选择排序

## 直接选择排序

- 每轮找最小值 → 与当前元素交换
- **不稳定**（跨区域交换）

**示例步骤**：

原数组：`[57, 52, 68, 59]`  

1. 找最小值 52 → 与 57 交换  
   `[52, 57, 68, 59]`
2. 剩余部分找最小值 57 → 已在正确位置  
   `[52, 57, 68, 59]`
3. 找最小值 59 → 与 68 交换  
   `[52, 57, 59, 68]`

| 特性 | 值 |
|------|----|
| 稳定性 | 不稳定 |
| 时间复杂度 | O(N²) |
| 空间复杂度 | O(1) |

---

## 堆排序（Heap Sort）

1. 构造大顶堆（或小顶堆）
2. 取出根节点（最大/最小值）
3. 将尾部元素移动到根，重新调整堆
4. 重复步骤 2-3，直到排序完成

**概念**：

- 小顶堆：父节点 ≤ 左右孩子 → 根最小
- 大顶堆：父节点 ≥ 左右孩子 → 根最大

| 特性 | 值 |
|------|----|
| 稳定性 | 不稳定 |
| 时间复杂度 | O(N log N) |
| 空间复杂度 | O(1) |

---

# 交换类排序

## 冒泡排序

- 相邻元素比较 → 小的向前移动，像气泡上浮。
- **稳定排序**，时间复杂度 O(N²)，空间复杂度 O(1)

**示例**：

原数组：`[68, 59, 52, 57]`  

1. 比较 68 和 59 → 59 上浮  
   `[59, 68, 52, 57]`
2. 比较 68 和 52 → 52 上浮  
   `[59, 52, 68, 57]`
3. 比较 68 和 57 → 57 上浮  
   `[59, 52, 57, 68]`

---

## 快速排序（Quick Sort）

- **分治法**：选基准元素 → 左小右大 → 递归排序两边
- **不稳定**，平均时间复杂度 O(N log N)，最坏 O(N²)

**示例**：

原数组：`[68, 59, 52, 57]`，基准元素 59  

1. 左边：小于 59 → `[52, 57]`  
2. 右边：大于 59 → `[68]`  
3. 合并 → `[52, 57, 59, 68]`

---

# 归并排序（Merge Sort）

- **分治法**：不断拆分 → 合并有序数组
- **稳定排序**，时间复杂度 O(N log N)，空间复杂度 O(N)

**步骤示例**：

原数组：`[68, 59, 52, 57]`  

1. 拆分：`[68, 59]` `[52, 57]`  
2. 各自排序：`[59, 68]` `[52, 57]`  
3. 合并：`[52, 57, 59, 68]`

---

# 排序算法总结表

| 算法 | 类别 | 稳定性 | 平均时间复杂度 | 空间复杂度 |
|------|------|--------|----------------|------------|
| 直接插入排序 | 插入类 | 稳定 | O(N²) | O(1) |
| 希尔排序 | 插入类 | 不稳定 | O(N^1.3) | O(1) |
| 直接选择排序 | 选择类 | 不稳定 | O(N²) | O(1) |
| 堆排序 | 选择类 | 不稳定 | O(N log N) | O(1) |
| 冒泡排序 | 交换类 | 稳定 | O(N²) | O(1) |
| 快速排序 | 交换类 | 不稳定 | O(N log N) | O(log N) |
| 归并排序 | 归并类 | 稳定 | O(N log N) | O(N) |

---

# 学习建议

1. 理解 **稳定性** 判断方法：相邻比较 → 稳定，跨区域 → 不稳定。
2. 熟悉 **三大类排序** 特性与升级版算法。
3. 通过 **手动演练示例数组** 理解排序流程。
4. 关注 **时间复杂度、空间复杂度** 及最优/最坏情况。

# 奇数排序与基数排序

## 基数排序概念

- 基数排序（Radix Sort）是一种**稳定排序**。
- 核心思想：按照数字的**每一位**依次排序，从低位到高位（LSD，Least Significant Digit）。
- 适合位数有限、数据量较大的整数排序。

---

## 基数排序示例

原始数组：`[135, 242, 192, 124, 219, 293]`

### 步骤 1：按个位排序

- 新建 0~9 的格子数组（桶），将每个数字根据个位放入对应桶。
  
  过程：
  - 135 → 个位 5 → 放入下标 5
  - 242 → 个位 2 → 放入下标 2
  - 192 → 个位 2 → 放入下标 2 → 链接在已有数据后（链式存储）

- 拉直数组得到：
124, 242, 192, 135, 219, 293

yaml
Copy code
> 注意：此时数组仍未完全有序。

---

### 步骤 2：按十位排序

- 根据十位重新放入桶：
- 124 → 十位 2 → 桶 2
- 242 → 十位 4 → 桶 4
- ...依次类推
- 拉直数组得到：
192, 124, 242, 135, 219, 293

yaml
Copy code

---

### 步骤 3：按百位排序

- 根据百位重新放入桶：
- 124 → 百位 1 → 桶 1
- 192 → 百位 1 → 桶 1
- ...依次类推
- 拉直数组得到最终有序结果：
124, 135, 192, 219, 242, 293

yaml
Copy code

---

## 特点总结

| 特性 | 值 |
|------|----|
| 稳定性 | 稳定（从低位开始放入桶，先后顺序不变） |
| 时间复杂度 | O(d * n)，d = 最大位数，n = 数据量 |
| 空间复杂度 | O(n + k)，k = 桶数（通常 10） |

---

# 排序算法综合总结

| 算法 | 类别 | 稳定性 | 平均时间复杂度 | 空间复杂度 | 适用场景 |
|------|------|--------|----------------|------------|------------|
| 直接插入排序 | 插入类 | 稳定 | O(N²) | O(1) | 数据量小或基本有序 |
| 希尔排序 | 插入类 | 不稳定 | O(N^1.3) | O(1) | 中等规模数据，提高插入排序效率 |
| 直接选择排序 | 选择类 | 不稳定 | O(N²) | O(1) | 数据量小 |
| 堆排序 | 选择类 | 不稳定 | O(N log N) | O(1) | 数据量大，要求时间复杂度低 |
| 冒泡排序 | 交换类 | 稳定 | O(N²) | O(1) | 数据基本有序时效率较高 |
| 快速排序 | 交换类 | 不稳定 | O(N log N) | O(log N) | 数据量大，常用高效排序 |
| 归并排序 | 归并类 | 稳定 | O(N log N) | O(N) | 数据量大且需要稳定排序 |
| 基数排序 | 非比较类 | 稳定 | O(d * N) | O(N + k) | 位数有限的整数排序 |

---

# 排序算法选择建议

1. **数据量小**：使用直接插入或直接选择排序，代码简单，效率可接受。
2. **数据基本有序**：直接插入或冒泡排序，减少交换次数，效率最高。
3. **位数有限、数据量大**：基数排序（奇数排序）优先。
4. **数据量大**：使用快速排序、堆排序、归并排序，降低时间复杂度。
5. **稳定性要求**：使用插入排序、冒泡排序、归并排序或基数排序。
6. **开发便利**：现代开发可借助工具快速生成快速排序、归并排序等实现。

---

# 学习要点

- **稳定性判断**：相邻元素比较 → 稳定；跨区域比较 → 可能不稳定。
- **时间复杂度**：
- 小数据量：O(N²) 可以接受
- 大数据量：选择 O(N log N) 或 O(d*N)
- **空间复杂度**：辅助数组或链表影响实际内存消耗。
- **排序思想**：
- 插入类：依次插入
- 选择类：找最值交换
- 交换类：相邻交换
- 归并/基数：分治与合并