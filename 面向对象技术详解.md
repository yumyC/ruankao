# 面向对象技术详解

## 面向对象基本概念

### 类与对象
**类(Class)**
- 定义：具有相同属性和方法的对象的集合
- 组成：属性(数据)、方法(操作)、构造函数、析构函数
- 特点：抽象数据类型，封装数据和操作

**对象(Object)**
- 定义：类的实例，具有状态和行为的实体
- 特征：标识唯一性、状态可变性、行为主动性
- 生命周期：创建 → 使用 → 销毁

### 面向对象三大特性

#### 1. 封装(Encapsulation)
**定义**：将数据和操作数据的方法结合在一起，隐藏对象的内部实现细节

**访问控制**
- **public(公有)**：类外部可以访问
- **private(私有)**：只有类内部可以访问
- **protected(保护)**：类内部和子类可以访问

**优点**
- 信息隐藏，降低复杂性
- 提高代码的可维护性和可重用性
- 防止数据被意外修改

#### 2. 继承(Inheritance)
**定义**：子类自动获得父类的属性和方法的机制

**继承类型**
- **单继承**：一个子类只有一个直接父类
- **多继承**：一个子类有多个直接父类
- **多层继承**：形成继承层次结构

**继承关系**
- **is-a关系**：子类是父类的一种特殊类型
- **方法重写(Override)**：子类重新定义父类的方法
- **方法重载(Overload)**：同一类中方法名相同但参数不同

#### 3. 多态(Polymorphism)
**定义**：同一个接口可以有不同的实现方式

**多态类型**
- **编译时多态**：方法重载、运算符重载
- **运行时多态**：虚函数、动态绑定

**实现机制**
- **虚函数表**：存储虚函数地址的表
- **动态绑定**：运行时确定调用哪个方法
- **接口实现**：通过接口定义统一的方法签名

## UML统一建模语言

### UML图分类
**结构图**
- 类图、对象图、包图、组件图、部署图、组合结构图

**行为图**
- 用例图、活动图、状态机图、时序图、通信图、交互概览图、时间图

### 用例图(Use Case Diagram)

#### 基本元素
**参与者(Actor)**
- 表示：人形图标
- 定义：与系统交互的外部实体
- 类型：主要参与者、次要参与者、系统参与者

**用例(Use Case)**
- 表示：椭圆形
- 定义：系统提供的一个功能或服务
- 特点：从用户角度描述系统功能

**系统边界**
- 表示：矩形框
- 作用：区分系统内部和外部

#### 关系类型
**关联关系(Association)**
- 表示：实线
- 含义：参与者与用例之间的通信关系

**包含关系(Include)**
- 表示：虚线箭头，标注<<include>>
- 含义：一个用例包含另一个用例的功能
- 用途：提取公共功能，避免重复

**扩展关系(Extend)**
- 表示：虚线箭头，标注<<extend>>
- 含义：在特定条件下扩展基本用例的功能
- 用途：处理异常情况或可选功能

**泛化关系(Generalization)**
- 表示：实线三角箭头
- 含义：子用例继承父用例的行为
- 用途：表示用例之间的继承关系

### 类图(Class Diagram)

#### 类的表示
```
┌─────────────────┐
│   类名(ClassName) │
├─────────────────┤
│ -属性1: 类型      │
│ +属性2: 类型      │
├─────────────────┤
│ +方法1(): 返回类型 │
│ -方法2(): 返回类型 │
└─────────────────┘
```

**可见性标识**
- `+` public(公有)
- `-` private(私有)
- `#` protected(保护)
- `~` package(包)

**属性表示**
- 格式：可见性 属性名: 类型 [多重性] = 默认值 {约束}
- 示例：`-name: String [1] = "未知" {只读}`

**方法表示**
- 格式：可见性 方法名(参数列表): 返回类型 {约束}
- 示例：`+getName(): String {查询}`

#### 类之间的关系

**关联关系(Association)**
- 表示：实线
- 含义：类之间的结构关系
- 多重性：1, 0..1, 1..*, 0..*, n..m
- 角色名：关联端的名称

**聚合关系(Aggregation)**
- 表示：空心菱形 + 实线
- 含义：整体与部分的关系，部分可以独立存在
- 示例：汽车聚合轮胎

**组合关系(Composition)**
- 表示：实心菱形 + 实线
- 含义：强聚合，部分不能独立于整体存在
- 示例：房子组合房间

**依赖关系(Dependency)**
- 表示：虚线箭头
- 含义：一个类使用另一个类
- 类型：使用依赖、创建依赖、调用依赖

**泛化关系(Generalization)**
- 表示：实线三角箭头
- 含义：继承关系，子类继承父类
- 特点：is-a关系

**实现关系(Realization)**
- 表示：虚线三角箭头
- 含义：类实现接口
- 接口表示：<<interface>>或I字形图标

### 时序图(Sequence Diagram)

#### 基本元素
**参与者(Actor)**
- 表示：矩形框
- 位置：图的顶部

**生命线(Lifeline)**
- 表示：垂直虚线
- 含义：对象的生存期

**激活框(Activation Box)**
- 表示：生命线上的矩形
- 含义：对象处于活动状态的时间

**消息(Message)**
- **同步消息**：实线箭头，调用者等待返回
- **异步消息**：开放箭头，调用者不等待
- **返回消息**：虚线箭头，返回结果
- **自调用消息**：指向自己的箭头

#### 控制结构
**选择结构(alt)**
```
alt [条件1]
    消息1
else [条件2]
    消息2
end
```

**循环结构(loop)**
```
loop [循环条件]
    消息
end
```

**并行结构(par)**
```
par
    消息1
and
    消息2
end
```

### 状态图(State Diagram)

#### 基本元素
**状态(State)**
- 表示：圆角矩形
- 内容：状态名/进入动作/退出动作/内部活动

**转换(Transition)**
- 表示：箭头
- 标注：事件[守卫条件]/动作

**初始状态**
- 表示：实心圆点

**终止状态**
- 表示：同心圆(外圆内实心圆)

#### 状态类型
**简单状态**：不包含子状态的状态

**复合状态**：包含子状态的状态
- 顺序复合状态：子状态按顺序执行
- 并发复合状态：子状态并行执行

**历史状态**：记录复合状态的历史信息
- 浅历史：H
- 深历史：H*

### 活动图(Activity Diagram)

#### 基本元素
**活动(Activity)**
- 表示：圆角矩形
- 含义：一个处理步骤

**判决点(Decision)**
- 表示：菱形
- 用途：条件分支

**合并点(Merge)**
- 表示：菱形
- 用途：分支合并

**分叉点(Fork)**
- 表示：粗黑线
- 用途：并行分支开始

**汇合点(Join)**
- 表示：粗黑线
- 用途：并行分支结束

**泳道(Swimlane)**
- 用途：区分不同的责任主体
- 类型：垂直泳道、水平泳道

## 设计模式

### 创建型模式

#### 单例模式(Singleton)
**意图**：确保一个类只有一个实例，并提供全局访问点

**结构**
```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

**应用场景**
- 配置管理器
- 日志记录器
- 数据库连接池

#### 工厂方法模式(Factory Method)
**意图**：定义创建对象的接口，让子类决定实例化哪个类

**结构**
- 抽象工厂：定义创建产品的接口
- 具体工厂：实现创建具体产品
- 抽象产品：定义产品接口
- 具体产品：实现产品接口

**应用场景**
- 数据库驱动程序
- 日志记录器
- 图形界面组件

#### 抽象工厂模式(Abstract Factory)
**意图**：提供创建一系列相关或相互依赖对象的接口

**与工厂方法的区别**
- 工厂方法：创建一种产品
- 抽象工厂：创建一系列产品

#### 建造者模式(Builder)
**意图**：将复杂对象的构建与表示分离

**结构**
- 建造者：定义构建接口
- 具体建造者：实现构建步骤
- 指挥者：控制构建过程
- 产品：被构建的复杂对象

### 结构型模式

#### 适配器模式(Adapter)
**意图**：将一个类的接口转换成客户希望的另一个接口

**类型**
- **对象适配器**：使用组合关系
- **类适配器**：使用继承关系

**应用场景**
- 系统集成
- 第三方库集成
- 遗留系统改造

#### 装饰器模式(Decorator)
**意图**：动态地给对象添加额外的职责

**结构**
- 组件：定义对象接口
- 具体组件：实现基本功能
- 装饰器：持有组件引用
- 具体装饰器：添加额外功能

**应用场景**
- 图形界面组件
- 数据流处理
- 权限控制

#### 外观模式(Facade)
**意图**：为子系统提供统一的高层接口

**优点**
- 简化接口
- 降低耦合
- 提高安全性

#### 代理模式(Proxy)
**意图**：为其他对象提供代理以控制对这个对象的访问

**类型**
- **远程代理**：控制远程对象访问
- **虚拟代理**：延迟创建开销大的对象
- **保护代理**：控制访问权限
- **智能引用**：提供额外服务

### 行为型模式

#### 观察者模式(Observer)
**意图**：定义对象间一对多的依赖关系

**结构**
- 主题：维护观察者列表
- 观察者：定义更新接口
- 具体主题：状态改变时通知观察者
- 具体观察者：实现更新操作

**应用场景**
- 事件处理系统
- 模型-视图架构
- 发布-订阅系统

#### 策略模式(Strategy)
**意图**：定义算法族，使它们可以互相替换

**结构**
- 策略：定义算法接口
- 具体策略：实现具体算法
- 上下文：使用策略的环境

**应用场景**
- 排序算法选择
- 支付方式选择
- 压缩算法选择

#### 命令模式(Command)
**意图**：将请求封装成对象

**结构**
- 命令：定义执行接口
- 具体命令：实现执行操作
- 调用者：发起命令
- 接收者：执行命令

**应用场景**
- 撤销/重做功能
- 宏命令
- 队列请求

#### 状态模式(State)
**意图**：允许对象在内部状态改变时改变其行为

**与策略模式的区别**
- 策略模式：客户端选择策略
- 状态模式：状态自动转换

#### 模板方法模式(Template Method)
**意图**：定义算法骨架，让子类实现特定步骤

**结构**
- 抽象类：定义模板方法和抽象步骤
- 具体类：实现抽象步骤

**应用场景**
- 框架设计
- 数据处理流程
- 测试框架

## SOLID设计原则详解

### 1. 单一职责原则(SRP)
**定义**：一个类应该只有一个引起它变化的原因

**违反SRP的症状**
- 类的方法数量过多
- 类的职责不明确
- 修改一个功能影响其他功能

### 2. 开闭原则(OCP)
**定义**：软件实体应该对扩展开放，对修改关闭

**实现方式**
- 抽象化：依赖抽象而不是具体实现
- 多态性：通过继承和接口实现扩展

### 3. 里氏替换原则(LSP)
**定义**：子类对象应该能够替换父类对象

**违反LSP的情况**
- 子类抛出父类没有的异常
- 子类加强了前置条件
- 子类削弱了后置条件

### 4. 接口隔离原则(ISP)
**定义**：客户端不应该依赖它不需要的接口

**实现方式**
- 接口分离：将大接口拆分成小接口
- 角色隔离：不同角色使用不同接口

### 5. 依赖倒置原则(DIP)
**定义**：高层模块不应该依赖低层模块，都应该依赖抽象

**实现方式**
- 依赖注入：通过构造函数、setter或接口注入依赖
- 控制反转：由容器管理对象依赖关系