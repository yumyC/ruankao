# 操作系统详解

**重要程度：高 | 考查频度：高**

## 目录
1. [进程管理](#进程管理)
2. [存储管理](#存储管理)
3. [文件系统](#文件系统)
4. [设备管理](#设备管理)
5. [系统调用与中断](#系统调用与中断)

---

## 进程管理

### 进程基本概念

#### 进程状态转换
```
新建 → 就绪 → 运行 → 阻塞 → 终止
     ↑      ↓      ↓
     └──────┴──────┘
```

- **新建（New）**：进程正在被创建
- **就绪（Ready）**：进程已准备好运行，等待CPU
- **运行（Running）**：进程正在CPU上执行
- **阻塞（Blocked）**：进程等待某个事件发生
- **终止（Terminated）**：进程执行完毕

#### 典型例题

**例题1：进程状态转换**
```
一个进程从就绪状态变为运行状态是由于（）
A) 该进程被调度程序选中
B) 时间片用完
C) 等待I/O操作完成
D) 进程执行了系统调用

答案：A
解析：进程调度程序选中就绪队列中的进程，分配CPU资源，
使进程从就绪状态转为运行状态。
```

### 进程同步与互斥

#### PV操作（信号量）

**信号量定义**：
- `P(S)`：申请资源，S = S - 1，若S < 0则阻塞
- `V(S)`：释放资源，S = S + 1，若S ≤ 0则唤醒一个等待进程

#### 经典同步问题

##### 1. 生产者-消费者问题
```c
// 信号量定义
semaphore mutex = 1;     // 互斥访问缓冲区
semaphore empty = n;     // 空缓冲区数量
semaphore full = 0;      // 满缓冲区数量

// 生产者进程
Producer() {
    while(true) {
        produce_item();
        P(empty);        // 申请空缓冲区
        P(mutex);        // 申请互斥访问
        put_item();      // 放入缓冲区
        V(mutex);        // 释放互斥访问
        V(full);         // 增加满缓冲区
    }
}

// 消费者进程
Consumer() {
    while(true) {
        P(full);         // 申请满缓冲区
        P(mutex);        // 申请互斥访问
        get_item();      // 从缓冲区取出
        V(mutex);        // 释放互斥访问
        V(empty);        // 增加空缓冲区
        consume_item();
    }
}
```

##### 2. 读者-写者问题
```c
// 信号量定义
semaphore mutex = 1;     // 保护readcount
semaphore wrt = 1;       // 写者互斥
int readcount = 0;       // 读者计数

// 读者进程
Reader() {
    P(mutex);
    readcount++;
    if(readcount == 1)   // 第一个读者
        P(wrt);          // 阻止写者
    V(mutex);
    
    read_data();         // 读数据
    
    P(mutex);
    readcount--;
    if(readcount == 0)   // 最后一个读者
        V(wrt);          // 允许写者
    V(mutex);
}

// 写者进程
Writer() {
    P(wrt);              // 申请写权限
    write_data();        // 写数据
    V(wrt);              // 释放写权限
}
```

#### 典型例题

**例题2：PV操作分析**
```
有3个进程P1、P2、P3共享一个容量为2的缓冲区，
初始时缓冲区为空。信号量empty=2, full=0, mutex=1。
执行序列：P1执行P(empty), P2执行P(full), P3执行P(mutex)
此时各信号量的值为？

解答：
初始：empty=2, full=0, mutex=1
P1执行P(empty)：empty = 2-1 = 1
P2执行P(full)：full = 0-1 = -1（P2被阻塞）
P3执行P(mutex)：mutex = 1-1 = 0

结果：empty=1, full=-1, mutex=0
P2进程被阻塞在full信号量上。
```

### 死锁

#### 死锁的必要条件
1. **互斥条件**：资源不能被多个进程同时使用
2. **占有等待条件**：进程持有资源的同时等待其他资源
3. **不可抢占条件**：资源不能被强制性地从进程中释放
4. **循环等待条件**：存在进程资源的循环等待链

#### 死锁处理策略
1. **预防**：破坏死锁的必要条件之一
2. **避免**：银行家算法，动态检查资源分配安全性
3. **检测**：允许死锁发生，定期检测并解除
4. **忽略**：鸵鸟策略，假设死锁不会发生

#### 银行家算法

**算法步骤**：
1. 检查请求是否超过需求
2. 检查请求是否超过可用资源
3. 试探性分配资源
4. 执行安全性检查
5. 若安全则正式分配，否则回滚

#### 典型例题

**例题3：银行家算法**
```
系统有3种资源A、B、C，数量分别为10、5、7。
当前时刻系统状态如下：

进程  已分配    最大需求   还需要
     A B C    A B C    A B C
P0   0 1 0    7 5 3    7 4 3
P1   2 0 0    3 2 2    1 2 2
P2   3 0 2    9 0 2    6 0 0
P3   2 1 1    2 2 2    0 1 1
P4   0 0 2    4 3 3    4 3 1

可用资源Available = (3,3,2)

判断当前状态是否安全，如果P1请求资源(1,0,2)能否分配？

解答：
1. 安全性检查：
   寻找Need ≤ Available的进程
   P1: (1,2,2) ≤ (3,3,2) ✓
   分配给P1后：Available = (3,3,2) + (2,0,0) = (5,3,2)
   
   P3: (0,1,1) ≤ (5,3,2) ✓
   分配给P3后：Available = (5,3,2) + (2,1,1) = (7,4,3)
   
   P4: (4,3,1) ≤ (7,4,3) ✓
   分配给P4后：Available = (7,4,3) + (0,0,2) = (7,4,5)
   
   P0: (7,4,3) ≤ (7,4,5) ✓
   P2: (6,0,0) ≤ (7,4,5) ✓
   
   安全序列：P1→P3→P4→P0→P2，当前状态安全。

2. P1请求(1,0,2)：
   检查：(1,0,2) ≤ (1,2,2) ✓ （不超过需求）
   检查：(1,0,2) ≤ (3,3,2) ✓ （不超过可用）
   
   试探分配后：
   P1已分配变为(3,0,2)，还需要(0,2,0)
   Available变为(2,3,0)
   
   重新进行安全性检查，发现仍然安全。
   
答案：可以分配。
```

### 进程调度算法

#### 常见调度算法

| 算法 | 特点 | 优点 | 缺点 |
|------|------|------|------|
| FCFS | 先来先服务 | 简单公平 | 平均等待时间长 |
| SJF | 短作业优先 | 平均等待时间最短 | 可能饿死长作业 |
| SRTF | 最短剩余时间优先 | 响应时间短 | 开销大，饿死问题 |
| RR | 时间片轮转 | 响应时间好 | 时间片选择影响性能 |
| 优先级 | 按优先级调度 | 重要作业优先 | 可能饿死低优先级 |

#### 典型例题

**例题4：进程调度计算**
```
有4个进程，到达时间和服务时间如下：
进程  到达时间  服务时间
P1      0        8
P2      1        4  
P3      2        9
P4      3        5

分别计算FCFS和SJF调度算法的平均等待时间和平均周转时间。

FCFS调度：
执行顺序：P1(0-8) → P2(8-12) → P3(12-21) → P4(21-26)

等待时间：
P1: 0-0 = 0
P2: 8-1 = 7
P3: 12-2 = 10  
P4: 21-3 = 18
平均等待时间 = (0+7+10+18)/4 = 8.75

周转时间：
P1: 8-0 = 8
P2: 12-1 = 11
P3: 21-2 = 19
P4: 26-3 = 23
平均周转时间 = (8+11+19+23)/4 = 15.25

SJF调度（非抢占）：
t=0: P1开始执行
t=1: P2到达，但P1未完成，继续执行P1
t=8: P1完成，选择最短的P2执行
t=12: P2完成，选择P4（服务时间5）
t=17: P4完成，执行P3
t=26: P3完成

执行顺序：P1(0-8) → P2(8-12) → P4(12-17) → P3(17-26)

等待时间：
P1: 0
P2: 8-1 = 7
P3: 17-2 = 15
P4: 12-3 = 9
平均等待时间 = (0+7+15+9)/4 = 7.75

周转时间：
P1: 8
P2: 11  
P3: 24
P4: 14
平均周转时间 = (8+11+24+14)/4 = 14.25
```

---

## 存储管理

### 内存分配方式

#### 连续分配
1. **单一连续分配**：整个内存只运行一个程序
2. **固定分区分配**：内存分为若干固定大小分区
3. **动态分区分配**：根据进程需要动态分配

#### 动态分区分配算法
- **首次适应（First Fit）**：从头开始找第一个足够大的空闲区
- **最佳适应（Best Fit）**：找最小的足够大的空闲区
- **最坏适应（Worst Fit）**：找最大的空闲区

#### 典型例题

**例题5：动态分区分配**
```
内存空闲区链表：100K→500K→200K→300K→600K
进程请求序列：212K, 417K, 112K, 426K

分别用首次适应和最佳适应算法分配，写出分配过程。

首次适应算法：
1. 请求212K：在500K中分配，剩余288K
   空闲区：100K→288K→200K→300K→600K
   
2. 请求417K：在600K中分配，剩余183K  
   空闲区：100K→288K→200K→300K→183K
   
3. 请求112K：在288K中分配，剩余176K
   空闲区：100K→176K→200K→300K→183K
   
4. 请求426K：无法分配（最大空闲区300K）

最佳适应算法：
1. 请求212K：在300K中分配，剩余88K
   空闲区：100K→500K→200K→88K→600K
   
2. 请求417K：在500K中分配，剩余83K
   空闲区：100K→83K→200K→88K→600K
   
3. 请求112K：在200K中分配，剩余88K
   空闲区：100K→83K→88K→88K→600K
   
4. 请求426K：在600K中分配，剩余174K
   空闲区：100K→83K→88K→88K→174K
```

### 分页存储管理

#### 基本概念
- **页面（Page）**：逻辑地址空间的固定大小块
- **页框（Frame）**：物理内存的固定大小块
- **页表（Page Table）**：页面到页框的映射表

#### 地址转换
```
逻辑地址 = 页号 + 页内偏移
物理地址 = 页框号 + 页内偏移

页号 = 逻辑地址 ÷ 页面大小
页内偏移 = 逻辑地址 % 页面大小
```

#### 典型例题

**例题6：分页地址转换**
```
某系统页面大小为4KB，进程P的页表如下：
页号  页框号
0     2
1     5  
2     1
3     8

逻辑地址2050对应的物理地址是多少？

解答：
页面大小 = 4KB = 4096B
页号 = 2050 ÷ 4096 = 0
页内偏移 = 2050 % 4096 = 2050

查页表：页号0对应页框号2
物理地址 = 页框号 × 页面大小 + 页内偏移
        = 2 × 4096 + 2050
        = 8192 + 2050
        = 10242

答案：物理地址为10242
```

### 分段存储管理

#### 基本概念
- **段（Segment）**：按程序逻辑结构划分的可变长度块
- **段表（Segment Table）**：段号到段基址和段长的映射

#### 地址转换
```
逻辑地址 = 段号 + 段内偏移
物理地址 = 段基址 + 段内偏移

检查：段内偏移 < 段长
```

#### 典型例题

**例题7：分段地址转换**
```
某进程的段表如下：
段号  段基址  段长
0     1000   800
1     2500   1200
2     4000   600

逻辑地址(1,300)对应的物理地址是多少？

解答：
段号 = 1，段内偏移 = 300
查段表：段1的段基址 = 2500，段长 = 1200
检查：300 < 1200 ✓（未越界）
物理地址 = 2500 + 300 = 2800

答案：物理地址为2800
```

### 虚拟存储器

#### 基本原理
- **局部性原理**：程序访问的局部性
- **请求分页**：需要时才调入页面
- **页面置换**：内存不足时换出页面

#### 页面置换算法

##### 1. FIFO（先进先出）
```
页面访问序列：1,2,3,4,1,2,5,1,2,3,4,5
内存块数：3

过程：
1: [1] - 缺页
2: [1,2] - 缺页  
3: [1,2,3] - 缺页
4: [4,2,3] - 缺页（换出1）
1: [4,1,3] - 缺页（换出2）
2: [4,1,2] - 缺页（换出3）
5: [5,1,2] - 缺页（换出4）
1: [5,1,2] - 命中
2: [5,1,2] - 命中
3: [5,3,2] - 缺页（换出1）
4: [5,3,4] - 缺页（换出2）
5: [5,3,4] - 命中

缺页次数：9次
```

##### 2. LRU（最近最少使用）
```
页面访问序列：1,2,3,4,1,2,5,1,2,3,4,5
内存块数：3

过程：
1: [1] - 缺页
2: [1,2] - 缺页
3: [1,2,3] - 缺页  
4: [4,2,3] - 缺页（换出1，最久未用）
1: [4,1,3] - 缺页（换出2）
2: [4,1,2] - 缺页（换出3）
5: [5,1,2] - 缺页（换出4）
1: [5,1,2] - 命中
2: [5,1,2] - 命中
3: [3,1,2] - 缺页（换出5）
4: [3,4,2] - 缺页（换出1）
5: [3,4,5] - 缺页（换出2）

缺页次数：10次
```

#### 典型例题

**例题8：页面置换算法比较**
```
比较FIFO、LRU、OPT三种页面置换算法的性能。
页面访问序列：7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1
内存块数：3

FIFO算法：缺页15次
LRU算法：缺页12次  
OPT算法：缺页9次

结论：
- OPT算法理论最优，但实际无法实现
- LRU算法性能较好，实际常用
- FIFO算法简单但可能出现Belady异常
```

---

## 文件系统

### 文件的逻辑结构

#### 1. 顺序文件
- **特点**：记录按某种顺序排列
- **优点**：顺序访问效率高
- **缺点**：插入删除困难

#### 2. 索引文件
- **特点**：建立索引表，通过索引访问记录
- **优点**：随机访问快
- **缺点**：需要额外的索引空间

#### 3. 索引顺序文件
- **特点**：结合顺序和索引的优点
- **结构**：数据区 + 索引区 + 溢出区

### 文件的物理结构

#### 1. 连续分配
- **特点**：文件占用连续的磁盘块
- **优点**：访问速度快，实现简单
- **缺点**：外部碎片，文件大小难以扩展

#### 2. 链接分配
- **特点**：文件各块通过指针链接
- **优点**：无外部碎片，文件可动态扩展
- **缺点**：随机访问慢，指针占用空间

#### 3. 索引分配
- **特点**：为每个文件建立索引块
- **优点**：支持随机访问，无外部碎片
- **缺点**：索引块占用空间

#### 典型例题

**例题9：文件分配方式**
```
某文件系统磁盘块大小为1KB，指针占4B。
一个10KB的文件分别采用连续、链接、索引分配方式，
计算各需要多少个磁盘块？

解答：
文件大小：10KB，需要10个数据块

连续分配：
需要10个连续磁盘块

链接分配：
每个数据块需要4B存储指针
每块可存储数据：1024-4=1020B
需要磁盘块数：⌈10240/1020⌉ = 11块

索引分配：
需要1个索引块存储10个指针（10×4=40B < 1KB）
总共需要：10（数据块）+ 1（索引块）= 11块
```

### 目录结构

#### 1. 单级目录
- **特点**：所有文件在一个目录下
- **优点**：简单
- **缺点**：文件名冲突，查找效率低

#### 2. 两级目录
- **特点**：用户目录 + 文件目录
- **优点**：解决文件名冲突
- **缺点**：不能分组

#### 3. 树形目录
- **特点**：层次结构，支持子目录
- **优点**：结构清晰，支持分组
- **缺点**：查找路径可能很长

#### 4. 无环图目录
- **特点**：允许文件有多个父目录
- **优点**：支持文件共享
- **缺点**：实现复杂

### 磁盘调度算法

#### 常见算法

1. **FCFS**：先来先服务
2. **SSTF**：最短寻道时间优先
3. **SCAN**：电梯算法，单向扫描
4. **C-SCAN**：循环扫描
5. **LOOK**：改进的SCAN，到最后一个请求就返回

#### 典型例题

**例题10：磁盘调度算法**
```
磁盘有200个磁道（0-199），当前磁头在53号磁道，
请求队列：98,183,37,122,14,124,65,67
磁头移动方向：向磁道号增加方向

分别用SSTF、SCAN、C-SCAN算法计算磁头移动距离。

SSTF算法：
53→65(12)→67(2)→37(30)→14(23)→98(84)→122(24)→124(2)→183(59)
总移动距离：12+2+30+23+84+24+2+59 = 236

SCAN算法（向右扫描）：
53→65(12)→67(2)→98(31)→122(24)→124(2)→183(59)→199(16)→37(162)→14(23)
总移动距离：12+2+31+24+2+59+16+162+23 = 331

C-SCAN算法：
53→65(12)→67(2)→98(31)→122(24)→124(2)→183(59)→199(16)→0(199)→14(14)→37(23)
总移动距离：12+2+31+24+2+59+16+199+14+23 = 382
```

---

## 设备管理

### I/O控制方式

#### 1. 程序直接控制
- **特点**：CPU直接控制I/O设备
- **优点**：简单，硬件成本低
- **缺点**：CPU利用率低

#### 2. 中断驱动
- **特点**：I/O完成时发出中断
- **优点**：CPU利用率提高
- **缺点**：每个字符都要中断

#### 3. DMA方式
- **特点**：DMA控制器直接访问内存
- **优点**：CPU几乎不参与数据传输
- **缺点**：硬件复杂

#### 4. 通道方式
- **特点**：专用处理器控制I/O
- **优点**：CPU完全解放
- **缺点**：成本高

### 设备分配

#### 设备分配算法
1. **先请求先分配**
2. **优先级高者先分配**
3. **短任务优先分配**

#### 设备独立性
- **逻辑设备名**：用户使用的设备名
- **物理设备名**：实际的设备标识
- **设备驱动程序**：控制具体设备的程序

#### 典型例题

**例题11：设备分配**
```
系统有2台打印机P1、P2，3个进程A、B、C同时请求打印机。
进程优先级：A(3)、B(1)、C(2)
使用优先级分配算法，写出分配过程。

解答：
1. 比较优先级：A(3) > C(2) > B(1)
2. 分配P1给进程A
3. 分配P2给进程C  
4. 进程B等待
5. A或C完成后，B获得释放的打印机

分配结果：A→P1, C→P2, B等待
```

---

## 系统调用与中断

### 系统调用

#### 系统调用类型
1. **进程控制**：fork、exec、exit、wait
2. **文件操作**：open、read、write、close
3. **设备管理**：ioctl、read、write
4. **信息维护**：getpid、alarm、sleep
5. **通信**：pipe、shmget、msgget

#### 系统调用过程
1. 用户程序调用库函数
2. 库函数执行系统调用指令
3. 切换到内核态
4. 内核执行相应服务
5. 返回用户态

### 中断系统

#### 中断类型
1. **外部中断**：I/O中断、时钟中断
2. **内部中断**：程序性中断、访管中断
3. **软件中断**：系统调用

#### 中断处理过程
1. 保护现场（寄存器、PSW等）
2. 识别中断源
3. 调用相应中断处理程序
4. 恢复现场
5. 返回被中断程序

#### 典型例题

**例题12：中断处理**
```
某系统时钟中断周期为10ms，进程时间片为50ms。
一个进程连续运行，会发生几次时钟中断？

解答：
时间片 = 50ms
时钟中断周期 = 10ms
中断次数 = 50ms ÷ 10ms = 5次

第5次时钟中断时，进程时间片用完，发生进程调度。
```

---

## 性能评价

### 系统性能指标

#### 1. 吞吐量
- **定义**：单位时间内完成的作业数
- **计算**：吞吐量 = 完成作业数 / 总时间

#### 2. 响应时间
- **定义**：从提交请求到开始响应的时间
- **影响因素**：调度算法、系统负载

#### 3. 周转时间
- **定义**：从作业提交到完成的总时间
- **计算**：周转时间 = 完成时间 - 提交时间

#### 4. CPU利用率
- **定义**：CPU忙碌时间占总时间的比例
- **计算**：CPU利用率 = CPU忙碌时间 / 总时间

#### 典型例题

**例题13：系统性能计算**
```
某系统在1小时内完成了120个作业，
其中CPU忙碌时间为50分钟，求：
1. 系统吞吐量
2. CPU利用率

解答：
1. 系统吞吐量 = 120作业 / 60分钟 = 2作业/分钟

2. CPU利用率 = 50分钟 / 60分钟 = 83.33%
```

---

## 学习建议

### 重点掌握
1. **进程同步**：PV操作、经典同步问题
2. **死锁处理**：银行家算法、死锁检测
3. **存储管理**：分页、分段、虚拟存储
4. **文件系统**：文件结构、目录管理
5. **调度算法**：进程调度、磁盘调度

### 解题技巧
1. **画图分析**：状态转换图、资源分配图
2. **步骤模拟**：算法执行过程的手工模拟
3. **公式记忆**：地址转换、性能计算公式
4. **概念理解**：操作系统基本概念和原理

### 常考题型
1. **PV操作**：同步互斥问题的分析
2. **银行家算法**：安全性检查和资源分配
3. **地址转换**：分页分段的地址计算
4. **调度算法**：各种调度算法的性能比较
5. **文件系统**：文件分配方式的优缺点

---

*本文档涵盖软件设计师考试中操作系统的所有重要知识点，建议结合实际操作系统的使用经验学习。*