# 面向对象技术详解

**重要程度：高 | 考查频度：高**

## 目录
1. [面向对象基本概念](#面向对象基本概念)
2. [UML建模语言](#uml建模语言)
3. [面向对象分析](#面向对象分析)
4. [面向对象设计](#面向对象设计)
5. [设计模式](#设计模式)
6. [面向对象程序设计](#面向对象程序设计)

---

## 面向对象基本概念

### 核心概念

#### 1. 对象（Object）
**定义**：对象是现实世界中实体的抽象，具有状态、行为和标识

**特征**：
- **状态（State）**：对象的属性值
- **行为（Behavior）**：对象能执行的操作
- **标识（Identity）**：区分不同对象的唯一标识

#### 2. 类（Class）
**定义**：类是具有相同属性和方法的对象的集合，是对象的模板

**组成**：
- **属性（Attribute）**：描述对象的特征
- **方法（Method）**：定义对象的行为
- **构造函数**：创建对象时的初始化方法

#### 3. 封装（Encapsulation）
**定义**：将数据和操作数据的方法结合在一起，隐藏内部实现细节

**访问控制**：
- **public**：公有，任何地方都可访问
- **private**：私有，只有类内部可访问
- **protected**：保护，类及其子类可访问

**优点**：
- 提高安全性
- 降低复杂性
- 提高可维护性

#### 4. 继承（Inheritance）
**定义**：子类继承父类的属性和方法，实现代码重用

**类型**：
- **单继承**：一个子类只有一个父类
- **多继承**：一个子类有多个父类

**关系**：
- **is-a关系**：子类是父类的一种
- **泛化/特化**：父类是子类的泛化，子类是父类的特化

#### 5. 多态（Polymorphism）
**定义**：同一接口可以有不同的实现，运行时确定具体调用哪个实现

**实现方式**：
- **重载（Overloading）**：同名方法不同参数
- **重写（Overriding）**：子类重新定义父类方法
- **接口实现**：不同类实现同一接口

#### 典型例题

**例题1：面向对象概念辨析**
```
以下关于面向对象概念的描述，正确的是：

A) 封装就是将数据隐藏起来，不让外界访问
B) 继承只能继承父类的公有成员
C) 多态是指一个类可以有多个对象
D) 抽象是指忽略不重要的细节，突出重要特征

答案：D

解析：
A) 错误：封装不仅是隐藏数据，还包括提供访问接口
B) 错误：继承可以继承父类的公有和保护成员
C) 错误：多态是指同一接口的不同实现
D) 正确：抽象是面向对象的重要概念，突出本质特征
```

**例题2：继承关系分析**
```
设计一个图形类层次结构：
- Shape（形状）：抽象基类，有计算面积的抽象方法
- Circle（圆形）：继承Shape，实现面积计算
- Rectangle（矩形）：继承Shape，实现面积计算
- Square（正方形）：继承Rectangle

分析这个设计是否合理，并说明理由。

解答：
设计基本合理，但有改进空间：

合理之处：
1. Shape作为抽象基类，定义了通用接口
2. Circle和Rectangle正确继承并实现了抽象方法
3. Square继承Rectangle符合is-a关系

可能的问题：
1. Square继承Rectangle可能违反里氏替换原则
   - Rectangle的setWidth()和setHeight()对Square不适用
   - Square的长宽应该始终相等

改进建议：
1. 让Square直接继承Shape
2. 或者重新设计Rectangle的接口
3. 考虑使用组合而不是继承
```

### 消息传递

#### 基本概念
**消息**：对象间通信的机制，包含接收者、消息名和参数

**消息传递过程**：
1. 发送者构造消息
2. 消息传递给接收者
3. 接收者解释消息
4. 接收者执行相应方法
5. 返回结果给发送者

#### 消息类型
1. **同步消息**：发送者等待接收者处理完成
2. **异步消息**：发送者不等待，继续执行
3. **广播消息**：一对多的消息传递

---

## UML建模语言

### UML概述

#### 定义
UML（Unified Modeling Language）是面向对象系统建模的标准语言，用于可视化、规约、构造和文档化软件系统。

#### UML图分类
1. **结构图**：描述系统的静态结构
2. **行为图**：描述系统的动态行为

### 结构图

#### 1. 类图（Class Diagram）

##### 基本元素
**类的表示**：
```
+-------------------+
|     类名          |
+-------------------+
| - 属性1: 类型     |
| + 属性2: 类型     |
+-------------------+
| + 方法1(): 返回类型|
| - 方法2(): 返回类型|
+-------------------+
```

**可见性标识**：
- `+`：public（公有）
- `-`：private（私有）
- `#`：protected（保护）
- `~`：package（包）

##### 关系类型

**1. 关联（Association）**
- **表示**：实线
- **含义**：类之间的结构关系
- **多重性**：1, 0..1, 1..*, 0..*, n..m

**2. 聚合（Aggregation）**
- **表示**：空心菱形 + 实线
- **含义**：整体-部分关系，部分可以独立存在
- **例子**：汽车-轮胎

**3. 组合（Composition）**
- **表示**：实心菱形 + 实线
- **含义**：强聚合，部分不能独立存在
- **例子**：房子-房间

**4. 依赖（Dependency）**
- **表示**：虚线箭头
- **含义**：一个类使用另一个类
- **例子**：方法参数、局部变量

**5. 泛化（Generalization）**
- **表示**：空心三角形 + 实线
- **含义**：继承关系
- **例子**：动物-狗

**6. 实现（Realization）**
- **表示**：空心三角形 + 虚线
- **含义**：类实现接口
- **例子**：类-接口

#### 2. 对象图（Object Diagram）
**用途**：显示特定时刻对象实例及其关系

**表示方法**：
```
+-------------------+
| 对象名:类名       |
+-------------------+
| 属性1 = 值1       |
| 属性2 = 值2       |
+-------------------+
```

#### 典型例题

**例题3：类图关系识别**
```
某图书管理系统的类图中有以下关系，判断关系类型：

1. 图书馆 ——◇ 图书
2. 读者 ——————— 借阅 ——————— 图书
3. 图书 ——————————————————————> 出版社
4. 电子书 ——————————————————————△ 图书
5. 图书管理系统 - - - - - - - - - -> 数据库

解答：
1. 聚合关系：图书馆包含图书，但图书可以独立存在
2. 关联关系：读者通过借阅关联图书，借阅是关联类
3. 关联关系：图书与出版社的关联
4. 泛化关系：电子书继承图书
5. 依赖关系：系统依赖数据库，虚线表示依赖
```

### 行为图

#### 1. 用例图（Use Case Diagram）

##### 基本元素
- **参与者（Actor）**：与系统交互的外部实体
- **用例（Use Case）**：系统提供的功能
- **系统边界**：系统的范围

##### 关系类型
**1. 关联关系**
- 参与者与用例之间的关系

**2. 包含关系（Include）**
- **表示**：<<include>>
- **含义**：基用例必须包含被包含用例
- **例子**：登录 <<include>> 验证密码

**3. 扩展关系（Extend）**
- **表示**：<<extend>>
- **含义**：在特定条件下执行扩展用例
- **例子**：取款 <<extend>> 打印凭条

**4. 泛化关系**
- 用例之间或参与者之间的继承关系

#### 2. 时序图（Sequence Diagram）

##### 基本元素
- **对象**：参与交互的对象
- **生命线**：对象存在的时间
- **激活**：对象处理消息的时间
- **消息**：对象间的通信

##### 消息类型
1. **同步消息**：实线箭头，发送者等待
2. **异步消息**：开放箭头，发送者不等待
3. **返回消息**：虚线箭头，返回结果
4. **自调用**：对象调用自己的方法

#### 3. 活动图（Activity Diagram）

##### 基本元素
- **开始节点**：实心圆
- **结束节点**：实心圆加圆圈
- **活动**：圆角矩形
- **判断节点**：菱形
- **合并节点**：菱形
- **分叉节点**：粗线
- **汇合节点**：粗线

##### 控制流
- **顺序流**：活动的先后顺序
- **分支流**：条件分支
- **并行流**：并发执行

#### 4. 状态图（State Diagram）

##### 基本元素
- **状态**：圆角矩形
- **初始状态**：实心圆
- **终止状态**：实心圆加圆圈
- **转换**：箭头线
- **事件**：触发转换的条件

##### 状态类型
1. **简单状态**：不包含子状态
2. **复合状态**：包含子状态
3. **并发状态**：同时处于多个状态

#### 典型例题

**例题4：时序图绘制**
```
网上购物系统中，顾客下订单的过程如下：
1. 顾客向系统提交订单
2. 系统检查库存
3. 库存充足时，系统创建订单
4. 系统向支付系统发送支付请求
5. 支付成功后，系统确认订单
6. 系统向顾客返回订单确认

绘制时序图。

解答：
参与对象：顾客、购物系统、库存系统、支付系统

时序图：
顾客    购物系统    库存系统    支付系统
 |         |          |          |
 |--提交订单->|          |          |
 |         |--检查库存-->|          |
 |         |<--库存充足--|          |
 |         |--创建订单   |          |
 |         |--支付请求------------>|
 |         |<--支付成功------------|
 |         |--确认订单   |          |
 |<--订单确认|          |          |
```

**例题5：状态图设计**
```
设计电梯的状态图，电梯有以下状态：
- 停止：电梯静止
- 上行：电梯向上运行
- 下行：电梯向下运行
- 开门：电梯门打开
- 关门：电梯门关闭

事件：上行请求、下行请求、到达楼层、开门按钮、关门按钮

解答：
状态转换：
停止 --上行请求--> 关门 --关门完成--> 上行
停止 --下行请求--> 关门 --关门完成--> 下行
上行 --到达目标楼层--> 停止 --开门按钮--> 开门
下行 --到达目标楼层--> 停止 --开门按钮--> 开门
开门 --关门按钮--> 关门 --关门完成--> 停止

状态图包含：
- 初始状态：停止
- 主要状态：停止、上行、下行、开门、关门
- 转换条件：各种事件触发
```

---

## 面向对象分析

### OOA概述

#### 定义
面向对象分析（Object-Oriented Analysis, OOA）是运用面向对象的思想和方法，对问题域进行分析，建立分析模型的过程。

#### 目标
1. **理解问题域**：深入理解用户需求
2. **建立概念模型**：抽象出核心概念
3. **确定系统边界**：明确系统范围
4. **识别关键对象**：找出重要的对象和类

### OOA过程

#### 1. 需求获取
**方法**：
- 访谈用户和领域专家
- 观察现有系统和业务流程
- 分析现有文档和资料
- 构建原型系统

#### 2. 用例建模
**步骤**：
1. 识别参与者
2. 识别用例
3. 描述用例
4. 建立用例关系
5. 绘制用例图

**用例描述模板**：
```
用例名称：[用例名]
参与者：[主要参与者]
前置条件：[执行前的条件]
后置条件：[执行后的状态]
主要流程：
1. [步骤1]
2. [步骤2]
...
异常流程：
- [异常情况及处理]
```

#### 3. 领域建模
**目标**：识别问题域中的核心概念和关系

**步骤**：
1. 识别候选类
2. 定义类的属性
3. 确定类之间的关系
4. 绘制领域模型图

**识别类的方法**：
- 名词分析法
- CRC卡片法
- 职责驱动设计

#### 典型例题

**例题6：用例建模**
```
某在线图书销售系统需要支持以下功能：
- 顾客可以浏览图书、搜索图书、查看图书详情
- 顾客可以将图书加入购物车、修改购物车、结算购买
- 顾客需要注册账户、登录系统
- 管理员可以管理图书信息、查看销售报表
- 系统需要处理支付和发货

进行用例建模。

解答：

参与者识别：
- 顾客（主要参与者）
- 管理员（主要参与者）
- 支付系统（外部系统）
- 物流系统（外部系统）

用例识别：
顾客相关：
- 用户注册
- 用户登录
- 浏览图书
- 搜索图书
- 查看图书详情
- 管理购物车
- 结算购买
- 支付订单

管理员相关：
- 管理图书信息
- 查看销售报表

用例关系：
- 结算购买 include 用户登录
- 支付订单 include 结算购买
- 管理购物车 extend 浏览图书（可选添加到购物车）
```

### 分析模式

#### 常见分析模式

#### 1. 账户-交易模式
**适用场景**：金融、会计系统

**核心类**：
- Account（账户）
- Transaction（交易）
- TransactionType（交易类型）

**关系**：
- 账户有多个交易
- 交易有特定类型

#### 2. 组织层次模式
**适用场景**：组织管理系统

**核心类**：
- Organization（组织）
- OrganizationUnit（组织单元）
- Person（人员）

**关系**：
- 组织包含组织单元
- 组织单元包含人员

#### 3. 产品-订单模式
**适用场景**：电商、销售系统

**核心类**：
- Product（产品）
- Order（订单）
- OrderItem（订单项）
- Customer（客户）

**关系**：
- 客户有多个订单
- 订单包含多个订单项
- 订单项关联产品

---

## 面向对象设计

### OOD概述

#### 定义
面向对象设计（Object-Oriented Design, OOD）是在分析模型基础上，设计软件系统的结构和行为，形成设计模型的过程。

#### 设计原则

#### 1. 单一职责原则（SRP）
**定义**：一个类应该只有一个引起它变化的原因

**示例**：
```java
// 违反SRP：Employee类承担了太多职责
class Employee {
    public void calculatePay() { ... }      // 薪资计算
    public void save() { ... }              // 数据持久化
    public void reportHours() { ... }       // 报告工时
}

// 符合SRP：职责分离
class Employee {
    // 只负责员工基本信息
}
class PayrollCalculator {
    public void calculatePay(Employee emp) { ... }
}
class EmployeeRepository {
    public void save(Employee emp) { ... }
}
class TimeReporter {
    public void reportHours(Employee emp) { ... }
}
```

#### 2. 开放封闭原则（OCP）
**定义**：软件实体应该对扩展开放，对修改封闭

**示例**：
```java
// 违反OCP：添加新形状需要修改现有代码
class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Rectangle) {
            Rectangle rect = (Rectangle) shape;
            return rect.width * rect.height;
        } else if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            return Math.PI * circle.radius * circle.radius;
        }
        return 0;
    }
}

// 符合OCP：通过继承扩展功能
abstract class Shape {
    public abstract double calculateArea();
}
class Rectangle extends Shape {
    public double calculateArea() {
        return width * height;
    }
}
class Circle extends Shape {
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}
```

#### 3. 里氏替换原则（LSP）
**定义**：子类对象应该能够替换父类对象而不影响程序正确性

#### 4. 接口隔离原则（ISP）
**定义**：客户端不应该依赖它不需要的接口

#### 5. 依赖倒置原则（DIP）
**定义**：高层模块不应该依赖低层模块，两者都应该依赖抽象

### 设计过程

#### 1. 架构设计
**目标**：确定系统的整体结构

**常见架构模式**：
- **分层架构**：表示层、业务层、数据层
- **MVC架构**：模型、视图、控制器
- **微服务架构**：服务拆分、独立部署

#### 2. 详细设计
**内容**：
- 类的详细设计
- 方法的算法设计
- 数据结构设计
- 接口设计

#### 3. 数据库设计
**步骤**：
1. 概念设计：E-R图
2. 逻辑设计：关系模式
3. 物理设计：存储结构

#### 典型例题

**例题7：设计原则应用**
```
某文档编辑器需要支持多种文档格式（Word、PDF、TXT），
每种格式有不同的打开、保存、打印方法。
请设计类结构，体现面向对象设计原则。

解答：

设计方案：

// 抽象文档类
abstract class Document {
    protected String fileName;
    
    public abstract void open();
    public abstract void save();
    public abstract void print();
}

// 具体文档类
class WordDocument extends Document {
    public void open() { /* Word特定的打开逻辑 */ }
    public void save() { /* Word特定的保存逻辑 */ }
    public void print() { /* Word特定的打印逻辑 */ }
}

class PDFDocument extends Document {
    public void open() { /* PDF特定的打开逻辑 */ }
    public void save() { /* PDF特定的保存逻辑 */ }
    public void print() { /* PDF特定的打印逻辑 */ }
}

// 文档工厂
abstract class DocumentFactory {
    public abstract Document createDocument();
}

class WordDocumentFactory extends DocumentFactory {
    public Document createDocument() {
        return new WordDocument();
    }
}

// 编辑器类
class DocumentEditor {
    public void processDocument(Document doc) {
        doc.open();
        // 编辑操作
        doc.save();
        doc.print();
    }
}

设计原则体现：
1. SRP：每个类只负责一种文档格式
2. OCP：添加新格式不需要修改现有代码
3. LSP：所有文档子类都可以替换Document
4. DIP：编辑器依赖抽象Document而不是具体类
```

---

## 设计模式

### 设计模式概述

#### 定义
设计模式是在特定环境下，为解决某一通用软件设计问题而提供的一套定制的解决方案。

#### 模式要素
1. **模式名称**：模式的标识
2. **问题**：模式要解决的问题
3. **解决方案**：设计的组成元素及其关系
4. **效果**：模式的优缺点和使用后果

#### 模式分类
1. **创建型模式**：对象创建机制
2. **结构型模式**：对象组合方式
3. **行为型模式**：对象交互和职责分配

### 创建型模式

#### 1. 单例模式（Singleton）

**意图**：确保一个类只有一个实例，并提供全局访问点

**适用场景**：
- 系统配置管理
- 数据库连接池
- 日志记录器

**实现方式**：

##### 饿汉式
```java
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```

##### 懒汉式（线程安全）
```java
public class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

#### 2. 工厂方法模式（Factory Method）

**意图**：定义创建对象的接口，让子类决定实例化哪个类

**结构**：
```java
// 抽象产品
abstract class Product {
    public abstract void use();
}

// 具体产品
class ConcreteProductA extends Product {
    public void use() {
        System.out.println("使用产品A");
    }
}

class ConcreteProductB extends Product {
    public void use() {
        System.out.println("使用产品B");
    }
}

// 抽象工厂
abstract class Factory {
    public abstract Product createProduct();
}

// 具体工厂
class ConcreteFactoryA extends Factory {
    public Product createProduct() {
        return new ConcreteProductA();
    }
}

class ConcreteFactoryB extends Factory {
    public Product createProduct() {
        return new ConcreteProductB();
    }
}
```

#### 3. 抽象工厂模式（Abstract Factory）

**意图**：提供创建一系列相关或相互依赖对象的接口

**适用场景**：
- 系统需要独立于产品创建、组合和表示
- 系统需要配置多个产品族之一

### 结构型模式

#### 1. 适配器模式（Adapter）

**意图**：将一个类的接口转换为客户希望的另一个接口

**结构**：
```java
// 目标接口
interface Target {
    void request();
}

// 需要适配的类
class Adaptee {
    public void specificRequest() {
        System.out.println("特殊请求");
    }
}

// 适配器
class Adapter implements Target {
    private Adaptee adaptee;
    
    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }
    
    public void request() {
        adaptee.specificRequest();
    }
}
```

#### 2. 装饰器模式（Decorator）

**意图**：动态地给对象添加额外的职责

**结构**：
```java
// 抽象组件
abstract class Component {
    public abstract void operation();
}

// 具体组件
class ConcreteComponent extends Component {
    public void operation() {
        System.out.println("基本操作");
    }
}

// 抽象装饰器
abstract class Decorator extends Component {
    protected Component component;
    
    public Decorator(Component component) {
        this.component = component;
    }
    
    public void operation() {
        component.operation();
    }
}

// 具体装饰器
class ConcreteDecorator extends Decorator {
    public ConcreteDecorator(Component component) {
        super(component);
    }
    
    public void operation() {
        super.operation();
        addedBehavior();
    }
    
    private void addedBehavior() {
        System.out.println("附加功能");
    }
}
```

### 行为型模式

#### 1. 观察者模式（Observer）

**意图**：定义对象间一对多的依赖关系，当一个对象状态改变时，所有依赖它的对象都得到通知

**结构**：
```java
import java.util.*;

// 抽象主题
abstract class Subject {
    private List<Observer> observers = new ArrayList<>();
    
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    public void detach(Observer observer) {
        observers.remove(observer);
    }
    
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }
}

// 抽象观察者
interface Observer {
    void update();
}

// 具体主题
class ConcreteSubject extends Subject {
    private String state;
    
    public String getState() {
        return state;
    }
    
    public void setState(String state) {
        this.state = state;
        notifyObservers();
    }
}

// 具体观察者
class ConcreteObserver implements Observer {
    private String name;
    private ConcreteSubject subject;
    
    public ConcreteObserver(String name, ConcreteSubject subject) {
        this.name = name;
        this.subject = subject;
    }
    
    public void update() {
        System.out.println(name + "收到通知，状态：" + subject.getState());
    }
}
```

#### 2. 策略模式（Strategy）

**意图**：定义算法族，分别封装起来，让它们之间可以互相替换

**结构**：
```java
// 抽象策略
interface Strategy {
    void algorithmInterface();
}

// 具体策略
class ConcreteStrategyA implements Strategy {
    public void algorithmInterface() {
        System.out.println("算法A");
    }
}

class ConcreteStrategyB implements Strategy {
    public void algorithmInterface() {
        System.out.println("算法B");
    }
}

// 上下文
class Context {
    private Strategy strategy;
    
    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public void contextInterface() {
        strategy.algorithmInterface();
    }
}
```

#### 典型例题

**例题8：设计模式选择**
```
某图形编辑器需要实现以下功能：
1. 支持多种图形（圆形、矩形、三角形）的创建
2. 支持撤销/重做操作
3. 支持图形的复制和粘贴
4. 支持为图形添加边框、阴影等效果
5. 当图形属性改变时，通知相关视图更新

为每个功能选择合适的设计模式并说明理由。

解答：

1. 图形创建 - 工厂方法模式
   理由：需要创建不同类型的图形对象，工厂方法可以封装创建逻辑

2. 撤销/重做 - 命令模式
   理由：将操作封装为命令对象，支持撤销和重做

3. 图形复制 - 原型模式
   理由：通过克隆现有对象创建新对象，避免重复初始化

4. 添加效果 - 装饰器模式
   理由：动态为图形添加功能，不修改原有类结构

5. 属性变化通知 - 观察者模式
   理由：图形状态改变时自动通知所有相关视图

设计优势：
- 各模式职责明确，易于维护
- 支持功能扩展，符合开放封闭原则
- 降低类间耦合，提高系统灵活性
```

---

## 面向对象程序设计

### 编程语言特性

#### Java语言特性

##### 1. 类和对象
```java
public class Person {
    // 属性
    private String name;
    private int age;
    
    // 构造方法
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // 方法
    public void introduce() {
        System.out.println("我是" + name + "，今年" + age + "岁");
    }
    
    // getter和setter方法
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}
```

##### 2. 继承
```java
public class Student extends Person {
    private String studentId;
    
    public Student(String name, int age, String studentId) {
        super(name, age);  // 调用父类构造方法
        this.studentId = studentId;
    }
    
    @Override
    public void introduce() {
        super.introduce();  // 调用父类方法
        System.out.println("学号：" + studentId);
    }
}
```

##### 3. 接口
```java
public interface Drawable {
    void draw();
    
    // Java 8+ 默认方法
    default void print() {
        System.out.println("打印图形");
    }
}

public class Circle implements Drawable {
    public void draw() {
        System.out.println("绘制圆形");
    }
}
```

##### 4. 抽象类
```java
public abstract class Shape {
    protected String color;
    
    public Shape(String color) {
        this.color = color;
    }
    
    // 抽象方法
    public abstract double getArea();
    
    // 具体方法
    public void setColor(String color) {
        this.color = color;
    }
}
```

#### C++语言特性

##### 1. 多重继承
```cpp
class A {
public:
    void funcA() { cout << "Function A" << endl; }
};

class B {
public:
    void funcB() { cout << "Function B" << endl; }
};

class C : public A, public B {
public:
    void funcC() { cout << "Function C" << endl; }
};
```

##### 2. 虚函数和多态
```cpp
class Base {
public:
    virtual void show() {
        cout << "Base class" << endl;
    }
    virtual ~Base() {}  // 虚析构函数
};

class Derived : public Base {
public:
    void show() override {
        cout << "Derived class" << endl;
    }
};
```

### 面向对象编程实践

#### 1. 异常处理
```java
public class BankAccount {
    private double balance;
    
    public void withdraw(double amount) throws InsufficientFundsException {
        if (amount > balance) {
            throw new InsufficientFundsException("余额不足");
        }
        balance -= amount;
    }
}

// 自定义异常
class InsufficientFundsException extends Exception {
    public InsufficientFundsException(String message) {
        super(message);
    }
}
```

#### 2. 泛型编程
```java
public class GenericStack<T> {
    private List<T> items = new ArrayList<>();
    
    public void push(T item) {
        items.add(item);
    }
    
    public T pop() {
        if (items.isEmpty()) {
            return null;
        }
        return items.remove(items.size() - 1);
    }
}
```

#### 3. 集合框架
```java
// List接口实现
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");

// Map接口实现
Map<String, Integer> map = new HashMap<>();
map.put("Java", 1995);
map.put("Python", 1991);

// 遍历集合
for (String item : list) {
    System.out.println(item);
}
```

#### 典型例题

**例题9：面向对象编程**
```
设计一个图书管理系统的核心类，要求：
1. Book类：包含书名、作者、ISBN、价格等属性
2. Library类：管理图书集合，支持添加、删除、查找图书
3. 支持按不同条件查找图书（书名、作者、ISBN）
4. 使用适当的设计模式

实现代码框架。

解答：

// 图书类
public class Book {
    private String title;
    private String author;
    private String isbn;
    private double price;
    
    public Book(String title, String author, String isbn, double price) {
        this.title = title;
        this.author = author;
        this.isbn = isbn;
        this.price = price;
    }
    
    // getter方法
    public String getTitle() { return title; }
    public String getAuthor() { return author; }
    public String getIsbn() { return isbn; }
    public double getPrice() { return price; }
    
    @Override
    public String toString() {
        return String.format("《%s》- %s (ISBN: %s, 价格: %.2f)", 
                           title, author, isbn, price);
    }
}

// 查找策略接口
interface SearchStrategy {
    List<Book> search(List<Book> books, String keyword);
}

// 按书名查找
class TitleSearchStrategy implements SearchStrategy {
    public List<Book> search(List<Book> books, String keyword) {
        return books.stream()
                   .filter(book -> book.getTitle().contains(keyword))
                   .collect(Collectors.toList());
    }
}

// 按作者查找
class AuthorSearchStrategy implements SearchStrategy {
    public List<Book> search(List<Book> books, String keyword) {
        return books.stream()
                   .filter(book -> book.getAuthor().contains(keyword))
                   .collect(Collectors.toList());
    }
}

// 图书馆类
public class Library {
    private List<Book> books;
    private SearchStrategy searchStrategy;
    
    public Library() {
        this.books = new ArrayList<>();
    }
    
    public void addBook(Book book) {
        books.add(book);
    }
    
    public boolean removeBook(String isbn) {
        return books.removeIf(book -> book.getIsbn().equals(isbn));
    }
    
    public void setSearchStrategy(SearchStrategy strategy) {
        this.searchStrategy = strategy;
    }
    
    public List<Book> searchBooks(String keyword) {
        if (searchStrategy == null) {
            throw new IllegalStateException("搜索策略未设置");
        }
        return searchStrategy.search(books, keyword);
    }
    
    public List<Book> getAllBooks() {
        return new ArrayList<>(books);  // 返回副本，保护内部数据
    }
}

// 使用示例
public class LibraryDemo {
    public static void main(String[] args) {
        Library library = new Library();
        
        // 添加图书
        library.addBook(new Book("Java编程思想", "Bruce Eckel", "978-0131872486", 89.0));
        library.addBook(new Book("设计模式", "GoF", "978-0201633612", 65.0));
        
        // 按书名搜索
        library.setSearchStrategy(new TitleSearchStrategy());
        List<Book> results = library.searchBooks("Java");
        results.forEach(System.out::println);
        
        // 按作者搜索
        library.setSearchStrategy(new AuthorSearchStrategy());
        results = library.searchBooks("Bruce");
        results.forEach(System.out::println);
    }
}

设计模式应用：
1. 策略模式：不同的搜索策略可以互换
2. 封装：Book类的属性私有化，提供访问方法
3. 组合：Library包含Book对象的集合
```

---

## 学习建议

### 重点掌握
1. **基本概念**：类、对象、封装、继承、多态的深入理解
2. **UML建模**：类图、用例图、时序图、状态图的绘制和解读
3. **设计原则**：SOLID原则的理解和应用
4. **设计模式**：常用设计模式的结构、意图和适用场景
5. **编程实践**：面向对象编程语言的特性和使用

### 解题技巧
1. **概念辨析**：准确理解面向对象的核心概念
2. **UML绘制**：掌握各种UML图的标准表示法
3. **模式识别**：能够识别问题适用的设计模式
4. **代码分析**：理解面向对象代码的结构和设计意图

### 常考题型
1. **概念选择题**：面向对象基本概念的理解
2. **UML图绘制**：根据需求绘制相应的UML图
3. **设计模式应用**：选择合适的设计模式解决问题
4. **代码分析题**：分析面向对象代码的设计
5. **系统设计题**：运用面向对象方法设计系统

### 实践建议
1. **编程练习**：用面向对象语言实现各种设计模式
2. **项目实战**：参与面向对象项目的分析和设计
3. **工具使用**：熟练使用UML建模工具
4. **案例学习**：分析优秀的面向对象系统设计

### 学习资源
1. **经典书籍**：《设计模式》、《UML用户指南》
2. **在线资源**：设计模式网站、UML教程
3. **实践平台**：GitHub开源项目、编程练习网站
4. **社区交流**：技术论坛、开发者社区

---

*本文档涵盖软件设计师考试中面向对象技术的所有重要知识点，建议结合实际编程实践学习使用。*