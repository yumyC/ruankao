# 数据结构与算法详解

**重要程度：高 | 考查频度：很高**

## 目录
1. [线性结构](#线性结构)
2. [树与二叉树](#树与二叉树)
3. [图论算法](#图论算法)
4. [排序算法](#排序算法)
5. [查找算法](#查找算法)
6. [动态规划与回溯](#动态规划与回溯)

---

## 线性结构

### 栈（Stack）- 后进先出（LIFO）

#### 核心概念
- **定义**：只能在一端进行插入和删除操作的线性表
- **基本操作**：
  - `push(x)`：入栈
  - `pop()`：出栈
  - `top()`：获取栈顶元素
  - `isEmpty()`：判断栈是否为空

#### 应用场景
1. **表达式求值**：中缀转后缀、后缀表达式计算
2. **函数调用**：函数调用栈、递归实现
3. **括号匹配**：检查括号是否配对
4. **浏览器历史**：前进后退功能

#### 典型例题

**例题1：中缀转后缀表达式**
```
将中缀表达式 "A + B * C - D / E" 转换为后缀表达式。

解题步骤：
1. 建立运算符优先级：* / > + - > (
2. 使用栈存储运算符
3. 遇到操作数直接输出
4. 遇到运算符按优先级处理

转换过程：
A + B * C - D / E
→ A B C * + D E / -

答案：A B C * + D E / -
```

**例题2：括号匹配检查**
```
判断字符串 "({[]})" 的括号是否匹配。

算法：
1. 遇到左括号入栈
2. 遇到右括号与栈顶匹配
3. 最后栈为空则匹配

过程：
( 入栈：[( ]
{ 入栈：[( { ]
[ 入栈：[( { [ ]
] 匹配[ 出栈：[( { ]
} 匹配{ 出栈：[( ]
) 匹配( 出栈：[ ]

答案：匹配
```

### 队列（Queue）- 先进先出（FIFO）

#### 核心概念
- **定义**：只能在一端插入、另一端删除的线性表
- **基本操作**：
  - `enqueue(x)`：入队
  - `dequeue()`：出队
  - `front()`：获取队首元素
  - `rear()`：获取队尾元素

#### 循环队列
- **优势**：避免假溢出，提高空间利用率
- **判满条件**：`(rear + 1) % maxSize == front`
- **判空条件**：`rear == front`

#### 典型例题

**例题3：循环队列操作**
```
设循环队列的容量为6，初始时队列为空（front=rear=0）。
依次执行以下操作后，front和rear的值分别是多少？
操作序列：入队A,B,C,D，出队2个元素，入队E,F,G

解答：
初始：front=0, rear=0
入队A：rear=1
入队B：rear=2  
入队C：rear=3
入队D：rear=4
出队A：front=1
出队B：front=2
入队E：rear=5
入队F：rear=0（循环）
入队G：rear=1

最终：front=2, rear=1
```

---

## 树与二叉树

### 二叉树遍历

#### 三种遍历方式
1. **前序遍历**：根 → 左 → 右
2. **中序遍历**：左 → 根 → 右  
3. **后序遍历**：左 → 右 → 根

#### 典型例题

**例题4：根据遍历序列构造二叉树**
```
已知二叉树的前序遍历为：A B D E C F
已知二叉树的中序遍历为：D B E A C F
求后序遍历序列。

解题步骤：
1. 前序第一个A是根节点
2. 在中序中找到A，左边DBE是左子树，右边CF是右子树
3. 递归处理左右子树

构造过程：
     A
   /   \
  B     C
 / \     \
D   E     F

后序遍历：D E B F C A
```

**例题5：二叉树的性质计算**
```
一棵完全二叉树有1000个节点，求：
1. 叶子节点的个数
2. 树的高度

解答：
设叶子节点数为n0，度为1的节点数为n1，度为2的节点数为n2
根据二叉树性质：
- n0 + n1 + n2 = 1000
- n0 = n2 + 1（叶子数=度为2的节点数+1）

完全二叉树中n1只能是0或1：
- 若n1=0：n0=n2+1，代入得2n0-1=1000，n0=500.5（不可能）
- 若n1=1：n0=n2+1，代入得2n0=1000，n0=500

所以叶子节点数为500个。

树的高度：⌊log₂1000⌋ + 1 = 10
```

### 哈夫曼树（最优二叉树）

#### 核心概念
- **定义**：带权路径长度最小的二叉树
- **构造算法**：
  1. 将所有节点按权值排序
  2. 选择两个权值最小的节点合并
  3. 重复直到只剩一个节点

#### 典型例题

**例题6：哈夫曼编码**
```
字符频率：A(5), B(9), C(12), D(13), E(16), F(45)
构造哈夫曼树并给出编码。

构造过程：
1. A(5) + B(9) = AB(14)
2. C(12) + D(13) = CD(25)  
3. AB(14) + E(16) = ABE(30)
4. CD(25) + ABE(30) = CDABE(55)
5. F(45) + CDABE(55) = 根(100)

哈夫曼编码：
F: 0
C: 100
D: 101  
A: 1100
B: 1101
E: 111

平均编码长度 = (45×1 + 12×3 + 13×3 + 5×4 + 9×4 + 16×3) / 100 = 2.24
```

---

## 图论算法

### 图的遍历

#### 深度优先搜索（DFS）
- **特点**：尽可能深入，回溯时访问其他分支
- **实现**：递归或栈
- **应用**：连通性检测、拓扑排序

#### 广度优先搜索（BFS）  
- **特点**：逐层访问，先访问距离近的节点
- **实现**：队列
- **应用**：最短路径、层次遍历

#### 典型例题

**例题7：图的遍历**
```
给定无向图的邻接矩阵：
    A B C D E
A [ 0 1 1 0 0 ]
B [ 1 0 0 1 1 ]  
C [ 1 0 0 0 1 ]
D [ 0 1 0 0 1 ]
E [ 0 1 1 1 0 ]

从顶点A开始进行DFS和BFS遍历。

DFS遍历（假设按字母顺序选择）：
A → B → D → E → C

BFS遍历：
A → B → C → D → E
```

### 最小生成树

#### Prim算法
1. 从任意顶点开始
2. 选择连接已访问顶点的最小权边
3. 重复直到所有顶点都被访问

#### Kruskal算法  
1. 将所有边按权值排序
2. 依次选择最小权边，不形成回路则加入
3. 重复直到有n-1条边

#### 典型例题

**例题8：最小生成树**
```
给定带权图的边：
AB(4), AC(2), AD(3), BC(1), BD(5), CD(6)

使用Kruskal算法求最小生成树：

1. 边按权值排序：BC(1), AC(2), AD(3), AB(4), BD(5), CD(6)
2. 选择BC(1)：不形成回路，加入
3. 选择AC(2)：不形成回路，加入  
4. 选择AD(3)：不形成回路，加入
5. 已有3条边，连接4个顶点，完成

最小生成树：BC(1) + AC(2) + AD(3) = 6
```

---

## 排序算法

### 常见排序算法比较

| 算法 | 时间复杂度(平均) | 时间复杂度(最坏) | 空间复杂度 | 稳定性 |
|------|------------------|------------------|------------|--------|
| 冒泡排序 | O(n²) | O(n²) | O(1) | 稳定 |
| 选择排序 | O(n²) | O(n²) | O(1) | 不稳定 |
| 插入排序 | O(n²) | O(n²) | O(1) | 稳定 |
| 快速排序 | O(nlogn) | O(n²) | O(logn) | 不稳定 |
| 归并排序 | O(nlogn) | O(nlogn) | O(n) | 稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(1) | 不稳定 |

#### 典型例题

**例题9：快速排序过程**
```
对数组 [6, 1, 2, 7, 9, 3, 4, 5, 10, 8] 进行快速排序，
以第一个元素为基准，写出第一趟排序后的结果。

过程：
基准pivot = 6
left = 1, right = 9

1. 从右向左找小于6的数：5
2. 从左向右找大于6的数：7
3. 交换：[6, 1, 2, 5, 9, 3, 4, 7, 10, 8]
4. 继续：找到4和9，交换：[6, 1, 2, 5, 4, 3, 9, 7, 10, 8]
5. 继续：找到3，left=right=5，交换基准：[3, 1, 2, 5, 4, 6, 9, 7, 10, 8]

第一趟结果：[3, 1, 2, 5, 4, 6, 9, 7, 10, 8]
基准6已就位，左边都小于6，右边都大于6。
```

---

## 查找算法

### 二分查找

#### 算法思想
- **前提**：有序数组
- **过程**：每次比较中间元素，缩小一半搜索范围
- **时间复杂度**：O(logn)

#### 典型例题

**例题10：二分查找过程**
```
在有序数组 [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] 中查找元素11。

查找过程：
1. left=0, right=9, mid=4, arr[4]=9 < 11, left=5
2. left=5, right=9, mid=7, arr[7]=15 > 11, right=6  
3. left=5, right=6, mid=5, arr[5]=11 = 11, 找到

比较次数：3次
```

### 哈希查找

#### 核心概念
- **哈希函数**：将关键字映射到地址
- **冲突处理**：
  - 开放定址法：线性探测、二次探测
  - 链地址法：冲突元素链接成链表

#### 典型例题

**例题11：哈希表构造**
```
关键字序列：{12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34}
哈希函数：H(key) = key % 12
采用线性探测法处理冲突，构造哈希表。

构造过程：
12: H(12) = 0, 存入地址0
67: H(67) = 7, 存入地址7  
56: H(56) = 8, 存入地址8
16: H(16) = 4, 存入地址4
25: H(25) = 1, 存入地址1
37: H(37) = 1, 冲突，探测到地址2存入
22: H(22) = 10, 存入地址10
29: H(29) = 5, 存入地址5
15: H(15) = 3, 存入地址3
47: H(47) = 11, 存入地址11
48: H(48) = 0, 冲突，探测到地址6存入  
34: H(34) = 10, 冲突，探测到地址9存入

最终哈希表：
地址: 0  1  2  3  4  5  6  7  8  9  10 11
值:  12 25 37 15 16 29 48 67 56 34 22 47
```

---

## 动态规划与回溯

### 动态规划

#### 核心思想
- **最优子结构**：问题的最优解包含子问题的最优解
- **状态转移方程**：描述状态间的转移关系
- **重叠子问题**：避免重复计算

#### 典型例题

**例题12：最长公共子序列（LCS）**
```
求字符串 "ABCDGH" 和 "AEDFHR" 的最长公共子序列。

动态规划解法：
设dp[i][j]表示前i个字符和前j个字符的LCS长度

状态转移方程：
if s1[i-1] == s2[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])

计算过程：
    ""  A  E  D  F  H  R
""   0  0  0  0  0  0  0
A    0  1  1  1  1  1  1
B    0  1  1  1  1  1  1  
C    0  1  1  1  1  1  1
D    0  1  1  2  2  2  2
G    0  1  1  2  2  2  2
H    0  1  1  2  2  3  3

LCS长度：3
LCS序列：ADH
```

### 回溯算法

#### 核心思想
- **试探性搜索**：尝试所有可能的解
- **回退机制**：发现不可行时回退到上一步
- **剪枝优化**：提前排除不可能的分支

#### 典型例题

**例题13：N皇后问题**
```
在4×4棋盘上放置4个皇后，使得任意两个皇后不能相互攻击。

回溯算法：
1. 逐行放置皇后
2. 检查列冲突、对角线冲突
3. 冲突则回溯，否则继续下一行

一个解：
Q . . .
. . Q .
. Q . .  
. . . Q

皇后位置：(0,0), (1,2), (2,1), (3,3)
```

---

## 算法复杂度分析

### 时间复杂度
- **O(1)**：常数时间，如数组访问
- **O(logn)**：对数时间，如二分查找
- **O(n)**：线性时间，如线性查找
- **O(nlogn)**：如归并排序、快速排序平均情况
- **O(n²)**：如冒泡排序、选择排序
- **O(2ⁿ)**：指数时间，如递归求斐波那契数列

### 空间复杂度
- **原地算法**：O(1)额外空间
- **递归算法**：O(递归深度)
- **动态规划**：O(状态数量)

#### 典型例题

**例题14：复杂度分析**
```
分析以下算法的时间复杂度：

for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
        // O(1)操作
    }
}

分析：
外层循环n次
内层循环分别执行：n, n-1, n-2, ..., 1次
总次数 = n + (n-1) + ... + 1 = n(n+1)/2 = O(n²)

时间复杂度：O(n²)
```

---

## 学习建议

### 重点掌握
1. **栈和队列**：基本操作、应用场景
2. **二叉树遍历**：三种遍历方式的递归和非递归实现
3. **图的遍历**：DFS和BFS的区别和应用
4. **排序算法**：快速排序、归并排序的原理和实现
5. **动态规划**：状态定义、转移方程、边界条件

### 练习方向
1. **手工模拟**：在纸上模拟算法执行过程
2. **代码实现**：用熟悉的语言实现核心算法
3. **复杂度分析**：分析算法的时间和空间复杂度
4. **应用场景**：理解算法的适用场景和局限性

### 常见陷阱
1. **边界条件**：空数组、单元素数组的处理
2. **稳定性**：排序算法的稳定性要求
3. **溢出问题**：大数运算时的溢出处理
4. **递归深度**：避免栈溢出

---

*本文档涵盖软件设计师考试中数据结构与算法的所有重要知识点，建议结合代码实践和真题练习使用。*