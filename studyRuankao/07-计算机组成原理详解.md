# 计算机组成原理详解

**重要程度：中 | 考查频度：中等**

## 目录
1. [数据表示与运算](#数据表示与运算)
2. [CPU组成与工作原理](#cpu组成与工作原理)
3. [存储系统](#存储系统)
4. [输入输出系统](#输入输出系统)
5. [指令系统](#指令系统)

---

## 数据表示与运算

### 数制转换

#### 常用数制
1. **二进制（Binary）**：基数为2，使用0和1
2. **八进制（Octal）**：基数为8，使用0-7
3. **十进制（Decimal）**：基数为10，使用0-9
4. **十六进制（Hexadecimal）**：基数为16，使用0-9和A-F

#### 数制转换方法

##### 十进制转其他进制
**方法**：除基取余法
```
十进制25转二进制：
25 ÷ 2 = 12 ... 1
12 ÷ 2 = 6  ... 0
6  ÷ 2 = 3  ... 0
3  ÷ 2 = 1  ... 1
1  ÷ 2 = 0  ... 1

从下往上读：25₁₀ = 11001₂
```

##### 其他进制转十进制
**方法**：按权展开法
```
二进制11001转十进制：
1×2⁴ + 1×2³ + 0×2² + 0×2¹ + 1×2⁰
= 16 + 8 + 0 + 0 + 1
= 25₁₀
```

##### 二进制与八进制、十六进制转换
```
二进制 ↔ 八进制：3位二进制 = 1位八进制
11001₂ = 011 001₂ = 31₈

二进制 ↔ 十六进制：4位二进制 = 1位十六进制  
11001₂ = 0001 1001₂ = 19₁₆
```

#### 典型例题

**例题1：数制转换**
```
将十进制数156转换为二进制、八进制和十六进制。

解答：
十进制156转二进制：
156 ÷ 2 = 78 ... 0
78  ÷ 2 = 39 ... 0
39  ÷ 2 = 19 ... 1
19  ÷ 2 = 9  ... 1
9   ÷ 2 = 4  ... 1
4   ÷ 2 = 2  ... 0
2   ÷ 2 = 1  ... 0
1   ÷ 2 = 0  ... 1

156₁₀ = 10011100₂

转八进制：
10011100₂ = 010 011 100₂ = 234₈

转十六进制：
10011100₂ = 1001 1100₂ = 9C₁₆

验证：
234₈ = 2×8² + 3×8¹ + 4×8⁰ = 128 + 24 + 4 = 156₁₀ ✓
9C₁₆ = 9×16¹ + 12×16⁰ = 144 + 12 = 156₁₀ ✓
```

### 数据表示

#### 整数表示

##### 原码表示
- **定义**：符号位+数值位的直接表示
- **范围**：n位原码表示范围 -(2ⁿ⁻¹-1) ~ +(2ⁿ⁻¹-1)
- **特点**：有+0和-0两种表示

##### 反码表示  
- **定义**：正数反码=原码，负数反码=符号位不变，数值位取反
- **用途**：补码运算的中间步骤

##### 补码表示
- **定义**：正数补码=原码，负数补码=反码+1
- **范围**：n位补码表示范围 -2ⁿ⁻¹ ~ +(2ⁿ⁻¹-1)
- **优点**：只有一个0，加减法统一处理

#### 典型例题

**例题2：补码运算**
```
用8位补码计算：(+25) + (-18)

解答：
+25的补码：
25₁₀ = 11001₂
8位补码：00011001

-18的补码：
18₁₀ = 10010₂
8位原码：00010010
8位反码：11101101  
8位补码：11101110

补码加法：
  00011001  (+25)
+ 11101110  (-18)
-----------
 100000111

丢弃进位，结果：00000111 = +7

验证：25 + (-18) = 7 ✓
```#### 浮点数表
示

##### IEEE 754标准
**单精度浮点数（32位）**：
- 符号位：1位
- 指数位：8位（偏置值127）
- 尾数位：23位

**双精度浮点数（64位）**：
- 符号位：1位
- 指数位：11位（偏置值1023）
- 尾数位：52位

##### 浮点数表示公式
```
V = (-1)^S × (1.M) × 2^(E-Bias)

其中：
S：符号位
M：尾数（小数部分）
E：指数（偏置后）
Bias：偏置值（单精度127，双精度1023）
```

#### 典型例题

**例题3：浮点数表示**
```
将十进制数-12.5表示为IEEE 754单精度浮点数。

解答：
1. 转换为二进制：
   12.5₁₀ = 1100.1₂

2. 规格化：
   1100.1₂ = 1.1001 × 2³

3. 确定各部分：
   符号位S = 1（负数）
   指数E = 3 + 127 = 130 = 10000010₂
   尾数M = 1001（省略整数部分的1）
   
4. 补齐位数：
   尾数补齐23位：10010000000000000000000

5. 组合结果：
   1 10000010 10010000000000000000000

验证：
(-1)¹ × 1.1001₂ × 2³ = -1.1001₂ × 8 = -12.5₁₀ ✓
```

### 算术运算

#### 加法运算
- **二进制加法**：0+0=0, 0+1=1, 1+0=1, 1+1=10
- **补码加法**：直接相加，溢出判断

#### 乘法运算
- **原码乘法**：符号位单独处理，数值位相乘
- **补码乘法**：Booth算法

#### 除法运算
- **原码除法**：符号位单独处理，数值位相除
- **补码除法**：加减交替法

#### 溢出检测
**补码溢出判断**：
- 两个正数相加结果为负数
- 两个负数相加结果为正数
- 符号位进位与最高数值位进位不同

---

## CPU组成与工作原理

### CPU基本组成

#### 1. 运算器（ALU）
**功能**：
- 算术运算：加、减、乘、除
- 逻辑运算：与、或、非、异或
- 移位运算：左移、右移

**组成**：
- 算术逻辑单元（ALU）
- 累加器（ACC）
- 数据缓冲寄存器（DR）
- 状态条件寄存器（PSW）

#### 2. 控制器
**功能**：
- 指令控制：取指、译码、执行
- 时序控制：产生时序信号
- 操作控制：产生操作控制信号

**组成**：
- 程序计数器（PC）
- 指令寄存器（IR）
- 指令译码器
- 时序产生器
- 微操作信号发生器

#### 3. 寄存器组
**类型**：
- **通用寄存器**：存储操作数和中间结果
- **专用寄存器**：特定功能寄存器
- **控制寄存器**：存储控制信息

### 指令执行过程

#### 指令周期
1. **取指周期（Fetch）**：从内存取指令到IR
2. **译码周期（Decode）**：分析指令操作和操作数
3. **执行周期（Execute）**：执行指令操作
4. **写回周期（Write Back）**：将结果写回寄存器或内存

#### 典型例题

**例题4：指令执行分析**
```
分析指令"ADD R1, R2, R3"（R1 = R2 + R3）的执行过程。

解答：
1. 取指周期：
   - PC内容送到地址总线
   - 从内存读取指令到IR
   - PC自增指向下一条指令

2. 译码周期：
   - 指令译码器分析IR内容
   - 识别操作：ADD（加法）
   - 识别操作数：R2、R3（源），R1（目标）

3. 执行周期：
   - 读取R2和R3的内容到ALU
   - ALU执行加法运算
   - 产生运算结果

4. 写回周期：
   - 将ALU结果写入R1
   - 更新状态标志位（如溢出标志）

微操作序列：
T1: MAR ← PC, PC ← PC + 1
T2: IR ← M[MAR]
T3: ALU ← R2 + R3
T4: R1 ← ALU, 更新标志位
```

### CPU性能指标

#### 1. 主频（Clock Frequency）
- **定义**：CPU时钟信号的频率
- **单位**：Hz（赫兹）
- **影响**：主频越高，执行速度越快

#### 2. CPI（Cycles Per Instruction）
- **定义**：执行一条指令平均需要的时钟周期数
- **计算**：CPI = 总时钟周期数 / 指令条数

#### 3. MIPS（Million Instructions Per Second）
- **定义**：每秒执行百万条指令数
- **计算**：MIPS = 主频 / (CPI × 10⁶)

#### 4. CPU执行时间
- **计算公式**：
  ```
  CPU时间 = 指令条数 × CPI × 时钟周期时间
  CPU时间 = 指令条数 × CPI / 主频
  ```

### 流水线技术

#### 流水线概念
**定义**：将指令执行过程分解为多个阶段，多条指令重叠执行

**优点**：
- 提高CPU利用率
- 增加指令吞吐率
- 减少平均指令执行时间

#### 流水线冲突

##### 1. 结构冲突（资源冲突）
- **原因**：多条指令竞争同一硬件资源
- **解决**：增加硬件资源或插入气泡

##### 2. 数据冲突
- **RAW冲突**：读后写冲突
- **WAR冲突**：写后读冲突  
- **WAW冲突**：写后写冲突
- **解决**：数据前推、插入气泡

##### 3. 控制冲突
- **原因**：分支指令改变程序执行流程
- **解决**：分支预测、延迟分支

#### 典型例题

**例题5：流水线性能分析**
```
某5级流水线CPU执行100条指令，每级流水线耗时1个时钟周期。
计算流水线的加速比和效率。

解答：
不使用流水线：
执行时间 = 100 × 5 = 500个时钟周期

使用流水线：
- 第1条指令需要5个周期完成
- 后续99条指令每条需要1个周期
- 总时间 = 5 + 99 = 104个时钟周期

加速比 = 500 / 104 ≈ 4.81

效率 = 加速比 / 流水线级数 = 4.81 / 5 ≈ 96.2%

理论最大加速比 = 5（流水线级数）
实际加速比接近理论值，说明流水线效果良好。
```

---

## 存储系统

### 存储器层次结构

#### 存储层次
```
CPU寄存器 ← 最快，最贵，容量最小
    ↓
Cache存储器
    ↓  
主存储器（内存）
    ↓
辅助存储器（硬盘）
    ↓
海量存储器 ← 最慢，最便宜，容量最大
```

#### 存储器性能指标
1. **存储容量**：能存储的信息量
2. **存取时间**：从发出访问请求到完成访问的时间
3. **存取周期**：连续两次访问之间的最小时间间隔
4. **存储器带宽**：单位时间内存储器与CPU之间传输的信息量

### 主存储器

#### 主存组织

##### 存储单元和地址
- **存储单元**：存储器中可独立寻址的最小单位
- **存储字**：存储器进行数据传输的基本单位
- **地址空间**：可寻址的存储单元总数

##### 主存容量计算
```
存储容量 = 存储单元个数 × 存储字长

例：地址线20位，数据线16位
存储单元个数 = 2²⁰ = 1M
存储字长 = 16位 = 2字节
存储容量 = 1M × 2B = 2MB
```

#### 主存类型

##### 1. RAM（随机存取存储器）
**SRAM（静态RAM）**：
- 特点：速度快，不需要刷新
- 应用：Cache、寄存器
- 缺点：成本高，功耗大

**DRAM（动态RAM）**：
- 特点：需要定期刷新，成本低
- 应用：主存储器
- 类型：SDRAM、DDR、DDR2、DDR3、DDR4

##### 2. ROM（只读存储器）
**类型**：
- **ROM**：出厂时写入，不可改写
- **PROM**：可编程ROM，只能写入一次
- **EPROM**：可擦除可编程ROM，紫外线擦除
- **EEPROM**：电可擦除可编程ROM
- **Flash**：闪存，块擦除

### Cache存储器

#### Cache工作原理
**基本思想**：利用程序的局部性原理，将常用数据存放在高速Cache中

**局部性原理**：
- **时间局部性**：最近访问的信息很可能再次被访问
- **空间局部性**：相邻地址的信息很可能被访问

#### Cache映射方式

##### 1. 直接映射
**映射关系**：主存块号 mod Cache块数
```
Cache块号 = 主存块号 % Cache块数
标记 = 主存块号 / Cache块数
```

**优点**：硬件简单，速度快
**缺点**：冲突率高，灵活性差

##### 2. 全相联映射
**映射关系**：主存任意块可映射到Cache任意位置

**优点**：冲突率低，灵活性好
**缺点**：硬件复杂，成本高

##### 3. 组相联映射
**映射关系**：直接映射和全相联映射的折中
```
组号 = 主存块号 % 组数
组内采用全相联映射
```

#### Cache替换算法
1. **FIFO**：先进先出
2. **LRU**：最近最少使用
3. **LFU**：最不经常使用
4. **随机替换**：随机选择替换块

#### 典型例题

**例题6：Cache映射计算**
```
某计算机主存容量1MB，Cache容量64KB，块大小64B。
采用直接映射方式，计算Cache的组织结构。

解答：
主存参数：
- 主存容量：1MB = 2²⁰B
- 块大小：64B = 2⁶B  
- 主存块数：2²⁰ / 2⁶ = 2¹⁴ = 16K块

Cache参数：
- Cache容量：64KB = 2¹⁶B
- Cache块数：2¹⁶ / 2⁶ = 2¹⁰ = 1K块

地址结构（20位）：
- 块内地址：6位（2⁶ = 64B）
- Cache块号：10位（2¹⁰ = 1K块）
- 标记位：4位（20 - 6 - 10 = 4位）

映射关系：
主存块号 = 标记位 × 1K + Cache块号
Cache块号 = 主存块号 % 1K

例如：主存地址 0x12345
- 二进制：00010010001101000101
- 标记：0001（1）
- Cache块号：0010001101（141）
- 块内地址：000101（5）
```

### 虚拟存储器

#### 虚拟存储概念
**定义**：将主存和辅存统一管理，为用户提供比主存更大的地址空间

**优点**：
- 扩大地址空间
- 提高内存利用率
- 实现程序的动态装入和链接
- 支持多道程序设计

#### 地址转换
**虚拟地址 → 物理地址**：
1. 页表查找
2. TLB（快表）加速
3. 缺页处理

#### 页面置换算法
1. **FIFO**：先进先出
2. **LRU**：最近最少使用
3. **OPT**：最佳置换算法（理论最优）
4. **Clock**：时钟算法

---

## 输入输出系统

### I/O系统组成

#### I/O设备分类
1. **按用途分类**：
   - 输入设备：键盘、鼠标、扫描仪
   - 输出设备：显示器、打印机、音箱
   - 存储设备：硬盘、光盘、U盘

2. **按传输速率分类**：
   - 低速设备：键盘、鼠标
   - 中速设备：打印机、磁盘
   - 高速设备：磁带、光纤通道

#### I/O接口
**功能**：
- 数据缓冲
- 信号转换
- 设备选择
- 状态监测
- 控制命令

### I/O控制方式

#### 1. 程序直接控制
**特点**：
- CPU直接控制I/O设备
- 采用查询方式
- CPU利用率低

**工作过程**：
1. CPU发出I/O命令
2. 启动I/O设备
3. CPU查询设备状态
4. 设备就绪后传输数据
5. 重复3-4直到传输完成

#### 2. 中断驱动I/O
**特点**：
- I/O设备主动通知CPU
- CPU可以执行其他程序
- 提高CPU利用率

**中断处理过程**：
1. 保护现场
2. 识别中断源
3. 调用中断处理程序
4. 恢复现场

#### 3. DMA方式
**特点**：
- 数据直接在内存和设备间传输
- CPU只需启动和结束时参与
- 大大提高传输效率

**DMA传输过程**：
1. CPU设置DMA控制器
2. DMA控制器接管总线
3. 直接进行数据传输
4. 传输完成后中断CPU

#### 4. 通道方式
**特点**：
- 专用处理器控制I/O
- CPU完全解放
- 适合大型机系统

#### 典型例题

**例题7：I/O方式比较**
```
某系统需要从磁盘读取1MB数据到内存，磁盘传输速率10MB/s，
CPU主频1GHz，每次中断处理需要1000个时钟周期。
比较中断方式和DMA方式的CPU开销。

解答：
数据传输时间 = 1MB / 10MB/s = 0.1s

中断方式：
假设每传输1KB产生一次中断
中断次数 = 1MB / 1KB = 1024次
中断处理时间 = 1024 × 1000 / 1GHz = 1.024ms
CPU开销 = 1.024ms / 0.1s = 1.024%

DMA方式：
只在开始和结束时各产生一次中断
中断次数 = 2次
中断处理时间 = 2 × 1000 / 1GHz = 0.002ms
CPU开销 = 0.002ms / 0.1s = 0.002%

结论：DMA方式的CPU开销远小于中断方式，
特别适合大批量数据传输。
```

---

## 指令系统

### 指令格式

#### 指令组成
1. **操作码（OP）**：指定操作类型
2. **地址码**：指定操作数地址

#### 指令格式类型
1. **零地址指令**：OP
   - 应用：堆栈操作、停机指令
   
2. **一地址指令**：OP A1
   - 应用：累加器结构
   
3. **二地址指令**：OP A1, A2
   - 应用：A1 = A1 OP A2
   
4. **三地址指令**：OP A1, A2, A3
   - 应用：A1 = A2 OP A3

### 寻址方式

#### 1. 立即寻址
**格式**：操作数直接在指令中
**优点**：速度快，不需要访问内存
**缺点**：操作数长度受限

#### 2. 直接寻址
**格式**：地址字段直接给出操作数地址
**优点**：简单直接
**缺点**：寻址范围受限

#### 3. 间接寻址
**格式**：地址字段给出操作数地址的地址
**优点**：扩大寻址范围
**缺点**：需要多次访问内存

#### 4. 寄存器寻址
**格式**：地址字段指定寄存器
**优点**：速度快
**缺点**：寄存器数量有限

#### 5. 寄存器间接寻址
**格式**：寄存器内容作为操作数地址
**优点**：灵活性好
**缺点**：需要额外的内存访问

#### 6. 相对寻址
**格式**：有效地址 = PC + 位移量
**应用**：程序转移指令

#### 7. 基址寻址
**格式**：有效地址 = 基址寄存器 + 位移量
**应用**：程序重定位

#### 8. 变址寻址
**格式**：有效地址 = 变址寄存器 + 位移量
**应用**：数组访问

### CISC与RISC

#### CISC（复杂指令集）
**特点**：
- 指令数量多，功能复杂
- 指令长度可变
- 寻址方式多样
- 微程序控制

**代表**：x86系列

#### RISC（精简指令集）
**特点**：
- 指令数量少，功能简单
- 指令长度固定
- 寻址方式简单
- 硬布线控制
- 大量通用寄存器

**代表**：ARM、MIPS

#### 典型例题

**例题8：寻址方式分析**
```
某指令格式为：MOV R1, 100(R2)
分析该指令的寻址方式和执行过程。

解答：
指令分析：
- 操作：MOV（数据传送）
- 目标：R1（寄存器寻址）
- 源：100(R2)（基址寻址）

寻址方式：
- R1：寄存器寻址
- 100(R2)：基址寻址，有效地址 = R2 + 100

执行过程：
1. 计算源操作数地址：EA = R2 + 100
2. 从内存地址EA读取数据
3. 将数据存入寄存器R1

例如：R2 = 1000
有效地址 = 1000 + 100 = 1100
指令功能：R1 ← M[1100]
```

---

## 学习建议

### 重点掌握
1. **数据表示**：二进制、补码、浮点数的表示和运算
2. **CPU结构**：运算器、控制器的组成和功能
3. **存储系统**：Cache工作原理、虚拟存储器
4. **I/O系统**：各种I/O控制方式的特点和应用
5. **指令系统**：寻址方式、CISC与RISC的区别

### 解题技巧
1. **数制转换**：熟练掌握各种数制间的转换方法
2. **补码运算**：理解补码的表示和运算规则
3. **Cache计算**：掌握Cache容量、命中率等计算
4. **性能分析**：能够分析和比较不同方案的性能

### 常考题型
1. **数制转换题**：各种进制间的相互转换
2. **补码运算题**：补码的表示和加减运算
3. **Cache分析题**：Cache的组织结构和性能计算
4. **流水线题**：流水线的性能分析和冲突处理
5. **I/O方式题**：不同I/O控制方式的比较

### 实践建议
1. **模拟实验**：使用模拟器理解CPU工作原理
2. **编程实践**：编写汇编程序理解指令执行
3. **性能测试**：测试不同存储器的访问性能
4. **硬件观察**：观察实际计算机硬件结构

---

*本文档涵盖软件设计师考试中计算机组成原理的重要知识点，建议结合实际硬件和编程实践学习使用。*