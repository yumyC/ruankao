# 软件工程详解

**重要程度：高 | 考查频度：很高**

## 目录
1. [软件生命周期与开发模型](#软件生命周期与开发模型)
2. [软件需求分析](#软件需求分析)
3. [软件设计](#软件设计)
4. [软件测试](#软件测试)
5. [软件维护](#软件维护)
6. [软件质量管理](#软件质量管理)
7. [软件项目管理](#软件项目管理)

---

## 软件生命周期与开发模型

### 软件生命周期

#### 基本阶段
1. **计划阶段**：问题定义、可行性研究
2. **开发阶段**：需求分析、设计、编码、测试
3. **运行阶段**：交付使用、维护

#### 详细阶段
1. **问题定义**：确定要解决的问题
2. **可行性研究**：技术、经济、操作可行性分析
3. **需求分析**：确定软件功能、性能、接口需求
4. **总体设计**：软件结构设计
5. **详细设计**：模块内部设计
6. **编码**：程序实现
7. **测试**：发现和修正错误
8. **维护**：修改和完善软件

### 软件开发模型

#### 1. 瀑布模型（Waterfall Model）

**特点**：
- 线性顺序开发
- 每个阶段有明确的输入输出
- 前一阶段完成后才能进入下一阶段

**优点**：
- 结构清晰，易于管理
- 适合需求明确、稳定的项目

**缺点**：
- 缺乏灵活性
- 用户参与度低
- 风险控制能力差

**适用场景**：需求明确、技术成熟的项目

#### 2. 增量模型（Incremental Model）

**特点**：
- 分批交付软件功能
- 每个增量都是可工作的软件
- 逐步完善系统功能

**优点**：
- 降低项目风险
- 用户可以早期使用部分功能
- 便于变更管理

**缺点**：
- 需要良好的架构设计
- 增量划分困难

#### 3. 原型模型（Prototype Model）

**特点**：
- 快速构建原型
- 用户参与评价
- 迭代改进

**类型**：
- **抛弃型原型**：用于需求确认后丢弃
- **演化型原型**：逐步演化为最终产品

**优点**：
- 用户参与度高
- 需求理解更准确
- 降低开发风险

**缺点**：
- 可能忽略质量要求
- 管理困难

#### 4. 螺旋模型（Spiral Model）

**特点**：
- 风险驱动的开发模型
- 结合瀑布模型和原型模型
- 迭代开发，每次迭代包含四个阶段

**四个象限**：
1. **制定计划**：确定目标、约束、备选方案
2. **风险分析**：识别和分析风险，构建原型
3. **实施工程**：开发和测试
4. **客户评估**：评价结果，规划下一轮

**优点**：
- 强调风险控制
- 适合大型复杂项目
- 支持需求变更

**缺点**：
- 模型复杂
- 需要风险评估专家

#### 5. 敏捷开发模型

##### Scrum方法
**角色**：
- **产品负责人（Product Owner）**：定义需求优先级
- **Scrum Master**：促进团队协作
- **开发团队**：实现产品功能

**活动**：
- **Sprint计划会议**：规划Sprint目标和任务
- **每日站会**：同步进度，识别障碍
- **Sprint评审**：展示完成的功能
- **Sprint回顾**：改进团队工作方式

**工件**：
- **产品Backlog**：需求列表
- **Sprint Backlog**：Sprint任务列表
- **产品增量**：可交付的软件

##### XP（极限编程）
**核心实践**：
- **结对编程**：两人协作编程
- **测试驱动开发**：先写测试再写代码
- **持续集成**：频繁集成代码
- **重构**：持续改进代码结构
- **简单设计**：保持设计简洁

#### 典型例题

**例题1：开发模型选择**
```
某公司要开发一个在线购物系统，项目特点如下：
- 需求不够明确，用户希望看到原型
- 项目规模较大，风险较高
- 用户希望能分阶段交付功能
- 开发周期较长

应该选择哪种开发模型？说明理由。

解答：
推荐使用螺旋模型，理由如下：

1. 风险驱动：项目规模大、风险高，螺旋模型强调风险分析和控制
2. 支持原型：每个螺旋周期都可以构建原型，满足用户需求
3. 迭代开发：可以分阶段交付功能，用户可以早期参与评价
4. 适合大型项目：螺旋模型专门为大型复杂项目设计

具体实施：
- 第一轮：需求原型，确定核心功能
- 第二轮：架构原型，验证技术可行性
- 第三轮：功能原型，实现核心业务逻辑
- 后续轮次：逐步完善和扩展功能
```

**例题2：敏捷开发实践**
```
某软件团队采用Scrum方法开发移动应用，团队包括：
- 1名产品负责人
- 1名Scrum Master  
- 6名开发人员
Sprint周期为2周

描述一个完整Sprint的活动安排。

解答：

Sprint规划（Sprint第1天）：
- Sprint计划会议（4小时）
  * 产品负责人介绍优先级最高的用户故事
  * 团队评估工作量，确定Sprint目标
  * 分解用户故事为具体任务

Sprint执行（Sprint第2-9天）：
- 每日站会（每天15分钟）
  * 昨天完成了什么
  * 今天计划做什么
  * 遇到什么障碍
- 开发工作
  * 结对编程
  * 测试驱动开发
  * 持续集成

Sprint评审（Sprint第10天上午）：
- Sprint评审会议（2小时）
  * 演示完成的功能
  * 收集利益相关者反馈
  * 更新产品Backlog

Sprint回顾（Sprint第10天下午）：
- Sprint回顾会议（1小时）
  * 回顾Sprint过程
  * 识别改进点
  * 制定改进计划
```

---

## 软件需求分析

### 需求的分类

#### 按内容分类
1. **功能需求**：系统必须提供的功能
2. **性能需求**：系统的性能指标
3. **接口需求**：与其他系统的接口
4. **设计约束**：设计和实现的限制条件

#### 按重要性分类
1. **必需需求**：系统必须实现的需求
2. **期望需求**：希望系统实现的需求
3. **可选需求**：如果时间允许可以实现的需求

### 需求获取方法

#### 1. 访谈法
- **结构化访谈**：预先准备问题清单
- **非结构化访谈**：开放式交流

#### 2. 问卷调查法
- 适合大量用户的需求收集
- 成本低，覆盖面广

#### 3. 观察法
- 观察用户实际工作过程
- 发现用户未意识到的需求

#### 4. 原型法
- 构建原型系统
- 用户体验后提出需求

### 需求分析方法

#### 1. 结构化分析方法

##### 数据流图（DFD）
**基本元素**：
- **外部实体**：系统外部的数据源或数据宿
- **处理**：对数据的变换
- **数据存储**：数据的存储
- **数据流**：数据的流动

**层次结构**：
- **顶层图**：整个系统的概览
- **0层图**：系统的主要功能
- **1层图及以下**：功能的详细分解

##### 数据字典（DD）
**内容**：
- 数据流的定义
- 数据存储的定义
- 处理的定义
- 外部实体的定义

#### 2. 面向对象分析方法

##### 用例图
**基本元素**：
- **参与者（Actor）**：与系统交互的外部实体
- **用例（Use Case）**：系统提供的功能
- **关系**：参与者与用例的关系

**用例关系**：
- **包含关系（Include）**：必须执行的子用例
- **扩展关系（Extend）**：可选执行的子用例
- **泛化关系**：用例间的继承关系

#### 典型例题

**例题3：数据流图绘制**
```
某图书管理系统的主要功能：
1. 读者借书：读者提供借书信息，系统检查读者状态和图书状态，
   更新借阅记录，打印借书单
2. 读者还书：读者提供还书信息，系统更新借阅记录，
   计算罚金（如有），打印还书单
3. 图书管理：管理员添加、删除、修改图书信息

绘制系统的0层数据流图。

解答：

外部实体：读者、管理员
数据存储：图书信息、读者信息、借阅记录
处理：借书处理、还书处理、图书管理

0层DFD：
```
读者 ——借书信息——→ 1.借书处理 ——借阅信息——→ 借阅记录
  ↑                    ↓
借书单              图书信息 ←——→ 图书信息
  ↑                    ↓
读者 ←——还书单—— 2.还书处理 ←——还书信息—— 读者
                      ↓
                   借阅记录

管理员 ——图书信息——→ 3.图书管理 ——→ 图书信息
```

**例题4：用例图设计**
```
网上购物系统的主要功能：
- 顾客可以浏览商品、搜索商品、添加到购物车、下订单、支付
- 管理员可以管理商品信息、处理订单、查看销售报表
- 系统需要与银行支付系统交互

绘制用例图。

解答：

参与者：顾客、管理员、银行支付系统

用例：
- 浏览商品
- 搜索商品  
- 管理购物车
- 下订单
- 支付订单
- 管理商品
- 处理订单
- 查看报表

关系：
- 下订单 include 管理购物车
- 支付订单与银行支付系统交互
```

### 需求规格说明

#### SRS文档结构
1. **引言**：目的、范围、定义
2. **总体描述**：产品功能、用户特征、约束
3. **具体需求**：功能需求、性能需求、接口需求
4. **附录**：数据字典、索引

#### 需求的质量特性
1. **正确性**：需求准确反映用户意图
2. **完整性**：需求覆盖所有必要功能
3. **一致性**：需求之间不矛盾
4. **可验证性**：需求可以测试验证
5. **可修改性**：需求易于修改和维护

---

## 软件设计

### 设计原则

#### 1. 模块化设计原则
- **高内聚**：模块内部元素联系紧密
- **低耦合**：模块间依赖关系最小
- **信息隐藏**：隐藏模块内部实现细节

#### 2. 抽象原则
- **过程抽象**：抽象出处理过程
- **数据抽象**：抽象出数据结构

#### 3. 逐步求精原则
- 自顶向下，逐层分解
- 每层都是上层的细化

### 结构化设计

#### 1. 总体设计

##### 软件结构图
**基本元素**：
- **模块**：具有特定功能的程序单元
- **调用关系**：模块间的调用
- **数据传递**：模块间的数据流

##### 设计准则
1. **深度优于宽度**：减少模块间接口
2. **扇入扇出适中**：
   - 扇入：调用该模块的模块数
   - 扇出：该模块调用的模块数
3. **作用域在控制域内**：数据作用范围在控制范围内

#### 2. 详细设计

##### 程序流程图
- **顺序结构**：按顺序执行
- **选择结构**：条件分支
- **循环结构**：重复执行

##### N-S图（盒图）
- 结构化程序设计工具
- 不使用goto语句
- 只有三种基本结构

#### 典型例题

**例题5：模块耦合度分析**
```
分析以下模块间耦合类型：

1. 模块A调用模块B，传递一个记录，B只使用记录中的部分字段
2. 模块C调用模块D，传递一个控制标志，D根据标志执行不同操作
3. 模块E和F都访问同一个全局变量
4. 模块G调用模块H，只传递H需要的具体数据

解答：

1. 标记耦合：传递了整个记录，但只使用部分字段，
   存在不必要的数据传递。

2. 控制耦合：传递控制标志，一个模块控制另一个模块的执行流程。

3. 公共耦合：通过全局变量通信，多个模块共享同一数据区域。

4. 数据耦合：只传递必要的数据，是最理想的耦合类型。

耦合度从强到弱：内容耦合 > 公共耦合 > 控制耦合 > 标记耦合 > 数据耦合
```

### 面向对象设计

#### 1. 基本概念
- **类**：对象的模板
- **对象**：类的实例
- **封装**：数据和方法的结合
- **继承**：子类继承父类特性
- **多态**：同一接口的不同实现

#### 2. 设计原则

##### SOLID原则
1. **单一职责原则（SRP）**：一个类只有一个变化原因
2. **开放封闭原则（OCP）**：对扩展开放，对修改封闭
3. **里氏替换原则（LSP）**：子类可以替换父类
4. **接口隔离原则（ISP）**：客户端不应依赖不需要的接口
5. **依赖倒置原则（DIP）**：依赖抽象而不是具体实现

#### 3. 设计模式

##### 创建型模式

###### 单例模式（Singleton）
**意图**：确保一个类只有一个实例

```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {}
    
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

###### 工厂模式（Factory）
**意图**：创建对象的接口，让子类决定实例化哪个类

```java
public abstract class ShapeFactory {
    public abstract Shape createShape();
}

public class CircleFactory extends ShapeFactory {
    public Shape createShape() {
        return new Circle();
    }
}
```

##### 结构型模式

###### 适配器模式（Adapter）
**意图**：将一个类的接口转换为客户希望的另一个接口

```java
public class AudioAdapter implements MediaPlayer {
    private AdvancedMediaPlayer advancedPlayer;
    
    public void play(String audioType, String fileName) {
        if (audioType.equals("mp4")) {
            advancedPlayer = new Mp4Player();
            advancedPlayer.playMp4(fileName);
        }
    }
}
```

##### 行为型模式

###### 观察者模式（Observer）
**意图**：定义对象间一对多的依赖关系

```java
public class Subject {
    private List<Observer> observers = new ArrayList<>();
    
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }
}
```

#### 典型例题

**例题6：设计模式应用**
```
某图形编辑器需要支持多种图形（圆形、矩形、三角形），
每种图形都有绘制和计算面积的功能。
用户可以撤销和重做操作。
系统需要记录操作日志。

分析应该使用哪些设计模式，并说明理由。

解答：

1. 工厂模式：创建不同类型的图形对象
   - 抽象工厂：ShapeFactory
   - 具体工厂：CircleFactory, RectangleFactory, TriangleFactory
   - 产品：Circle, Rectangle, Triangle

2. 命令模式：实现撤销和重做功能
   - 命令接口：Command（execute(), undo()）
   - 具体命令：DrawCommand, MoveCommand, DeleteCommand
   - 调用者：Editor（维护命令历史）

3. 观察者模式：记录操作日志
   - 主题：Editor
   - 观察者：Logger
   - 当执行操作时，通知Logger记录日志

设计优势：
- 工厂模式：易于扩展新的图形类型
- 命令模式：操作可撤销，支持宏命令
- 观察者模式：日志记录与核心逻辑解耦
```

---

## 软件测试

### 测试基本概念

#### 测试的目的
1. **发现错误**：找出程序中的缺陷
2. **验证功能**：确认软件满足需求
3. **评估质量**：评价软件质量水平

#### 测试原则
1. **测试显示缺陷存在**：不能证明程序正确
2. **穷尽测试不可能**：不可能测试所有情况
3. **早期测试**：越早发现错误，修复成本越低
4. **缺陷集群性**：错误往往集中在少数模块
5. **杀虫剂悖论**：重复的测试用例发现新错误的能力递减

### 测试分类

#### 按测试阶段分类
1. **单元测试**：测试单个模块
2. **集成测试**：测试模块间接口
3. **系统测试**：测试整个系统
4. **验收测试**：用户验收

#### 按测试方法分类
1. **黑盒测试**：基于功能规格说明
2. **白盒测试**：基于程序内部结构
3. **灰盒测试**：结合黑盒和白盒

#### 按测试策略分类
1. **静态测试**：不执行程序的测试
2. **动态测试**：执行程序的测试

### 黑盒测试方法

#### 1. 等价类划分
**基本思想**：将输入域划分为若干等价类，从每个等价类中选择测试用例

**等价类类型**：
- **有效等价类**：满足需求的输入
- **无效等价类**：不满足需求的输入

#### 2. 边界值分析
**基本思想**：在等价类边界及其附近选择测试用例

**选择原则**：
- 边界值本身
- 刚好超过边界的值
- 刚好小于边界的值

#### 3. 判定表驱动
**适用场景**：输入条件的组合较多，输出依赖于输入条件的组合

**组成部分**：
- **条件桩**：输入条件
- **动作桩**：输出动作
- **条件项**：条件的取值
- **动作项**：动作的执行

#### 典型例题

**例题7：等价类划分和边界值分析**
```
某程序要求输入一个1-100之间的整数，
使用等价类划分和边界值分析设计测试用例。

解答：

等价类划分：
有效等价类：
- E1: 1 ≤ x ≤ 100

无效等价类：
- E2: x < 1
- E3: x > 100  
- E4: x为非整数
- E5: x为非数字

测试用例（等价类）：
1. 输入50（E1）- 有效
2. 输入0（E2）- 无效
3. 输入101（E3）- 无效
4. 输入1.5（E4）- 无效
5. 输入"abc"（E5）- 无效

边界值分析：
边界值：1, 100
测试用例（边界值）：
1. 输入0（边界下方）
2. 输入1（下边界）
3. 输入2（边界上方）
4. 输入99（边界下方）
5. 输入100（上边界）
6. 输入101（边界上方）
```

**例题8：判定表设计**
```
某ATM取款系统的业务规则：
- 卡有效且密码正确且余额充足：允许取款
- 卡有效且密码正确且余额不足：提示余额不足
- 卡有效且密码错误：提示密码错误
- 卡无效：提示卡无效

设计判定表。

解答：

判定表：
条件\规则    R1  R2  R3  R4
卡有效      Y   Y   Y   N
密码正确    Y   Y   N   -
余额充足    Y   N   -   -
-----------+---+---+---+---
允许取款    X   -   -   -
余额不足    -   X   -   -
密码错误    -   -   X   -
卡无效      -   -   -   X

测试用例：
1. 有效卡+正确密码+充足余额 → 允许取款
2. 有效卡+正确密码+余额不足 → 提示余额不足
3. 有效卡+错误密码 → 提示密码错误
4. 无效卡 → 提示卡无效
```

### 白盒测试方法

#### 1. 语句覆盖
**定义**：每个语句至少执行一次

#### 2. 判定覆盖（分支覆盖）
**定义**：每个判定的真假分支都至少执行一次

#### 3. 条件覆盖
**定义**：每个条件的真假值都至少出现一次

#### 4. 判定/条件覆盖
**定义**：同时满足判定覆盖和条件覆盖

#### 5. 条件组合覆盖
**定义**：每个判定中条件的所有可能组合都至少出现一次

#### 6. 路径覆盖
**定义**：程序中每条可能的执行路径都至少执行一次

#### 典型例题

**例题9：白盒测试覆盖分析**
```
程序段：
if (A > 1 && B == 0)
    X = X / A;
if (A == 2 || X > 1)
    X = X + 1;

设计测试用例实现判定/条件覆盖。

解答：

判定和条件分析：
判定1: (A > 1 && B == 0)
- 条件1: A > 1
- 条件2: B == 0

判定2: (A == 2 || X > 1)  
- 条件3: A == 2
- 条件4: X > 1

覆盖要求：
判定覆盖：判定1和判定2的真假分支都要覆盖
条件覆盖：条件1,2,3,4的真假值都要覆盖

测试用例：
用例1: A=2, B=0, X=4
- A>1为真, B==0为真 → 判定1为真
- 执行X=X/A, X=4/2=2
- A==2为真 → 判定2为真
- 执行X=X+1, X=2+1=3

用例2: A=1, B=1, X=1  
- A>1为假, B==0为假 → 判定1为假
- A==2为假, X>1为假 → 判定2为假

覆盖情况：
- 判定1: 真(用例1), 假(用例2) ✓
- 判定2: 真(用例1), 假(用例2) ✓
- A>1: 真(用例1), 假(用例2) ✓
- B==0: 真(用例1), 假(用例2) ✓
- A==2: 真(用例1), 假(用例2) ✓
- X>1: 真(用例1), 假(用例2) ✓
```

### 集成测试

#### 集成策略
1. **大爆炸集成**：所有模块同时集成
2. **增量集成**：逐步集成模块

#### 增量集成方法
1. **自顶向下集成**：
   - 从主控模块开始
   - 使用桩模块（Stub）代替下层模块
   - 逐步用真实模块替换桩模块

2. **自底向上集成**：
   - 从底层模块开始
   - 使用驱动模块（Driver）调用底层模块
   - 逐步集成上层模块

3. **三明治集成**：
   - 结合自顶向下和自底向上
   - 从中间层开始，向上下两个方向集成

#### 典型例题

**例题10：集成测试策略**
```
某系统模块结构如下：
       A
     /   \
    B     C
   / \   / \
  D   E F   G

选择合适的集成测试策略并说明集成顺序。

解答：

方案1：自顶向下集成
集成顺序：A → A+B → A+B+C → A+B+D+C → A+B+D+E+C → A+B+D+E+C+F → A+B+D+E+C+F+G

需要的桩模块：
- 第1步：B_stub, C_stub
- 第2步：D_stub, E_stub, C_stub  
- 第3步：D_stub, E_stub, F_stub, G_stub
- 逐步减少桩模块

优点：早期发现接口错误，符合软件开发流程
缺点：需要编写较多桩模块

方案2：自底向上集成
集成顺序：D,E,F,G → D+E+B → F+G+C → D+E+B+F+G+C+A

需要的驱动模块：
- 第1步：D_driver, E_driver, F_driver, G_driver
- 第2步：B_driver, C_driver
- 第3步：A_driver（或直接使用A）

优点：不需要桩模块，底层模块测试充分
缺点：系统级错误发现较晚

推荐：三明治集成
先集成B和C子系统，再集成整个系统，平衡两种方法的优缺点。
```

### 软件测试管理

#### 测试计划
1. **测试目标**：明确测试要达到的目标
2. **测试范围**：确定测试的功能范围
3. **测试策略**：选择测试方法和技术
4. **测试资源**：人员、工具、环境
5. **测试进度**：测试活动的时间安排

#### 缺陷管理
1. **缺陷报告**：详细描述缺陷信息
2. **缺陷跟踪**：跟踪缺陷修复过程
3. **缺陷分析**：分析缺陷原因和趋势

#### 测试度量
1. **覆盖率**：代码覆盖率、需求覆盖率
2. **缺陷密度**：单位代码的缺陷数量
3. **测试效率**：发现缺陷的效率

---

## 软件维护

### 维护的定义和特点

#### 定义
软件维护是指在软件交付使用后，为了改正错误、改善性能或适应环境变化而进行的修改活动。

#### 特点
1. **维护成本高**：占软件总成本的60%-80%
2. **维护困难大**：需要理解已有代码
3. **影响范围广**：修改可能引入新错误

### 维护类型

#### 1. 纠错性维护（Corrective Maintenance）
- **目的**：修正软件错误
- **特点**：被动维护，必须进行
- **比例**：约占维护工作的20%

#### 2. 适应性维护（Adaptive Maintenance）
- **目的**：适应环境变化
- **内容**：操作系统升级、硬件更换、法规变化
- **比例**：约占维护工作的25%

#### 3. 完善性维护（Perfective Maintenance）
- **目的**：改善软件性能，增加功能
- **内容**：性能优化、功能扩展、用户界面改进
- **比例**：约占维护工作的50%

#### 4. 预防性维护（Preventive Maintenance）
- **目的**：预防未来可能出现的问题
- **内容**：代码重构、文档更新、结构改进
- **比例**：约占维护工作的5%

#### 典型例题

**例题11：维护类型识别**
```
某银行系统在使用过程中需要进行以下修改，
判断每种修改属于哪种维护类型：

1. 修正计算利息时的舍入错误
2. 增加手机银行功能
3. 适配新的操作系统Windows 11
4. 重构代码以提高可读性
5. 优化查询性能，减少响应时间

解答：

1. 纠错性维护：修正程序错误，确保计算正确性

2. 完善性维护：增加新功能，满足用户新需求

3. 适应性维护：适应操作系统环境变化

4. 预防性维护：改善代码结构，预防未来维护困难

5. 完善性维护：改善系统性能，提升用户体验
```

### 维护过程

#### 维护活动
1. **维护请求分析**：分析维护请求的合理性
2. **影响分析**：评估修改对系统的影响
3. **修改设计**：设计修改方案
4. **修改实现**：编码实现修改
5. **维护测试**：测试修改的正确性
6. **维护验收**：确认修改满足要求

#### 维护管理
1. **配置管理**：控制软件版本和变更
2. **文档管理**：维护相关文档的一致性
3. **质量保证**：确保维护质量

### 可维护性设计

#### 提高可维护性的方法
1. **模块化设计**：降低模块间耦合
2. **标准化编程**：遵循编程规范
3. **完善文档**：提供详细的设计和用户文档
4. **代码注释**：添加清晰的代码注释
5. **版本控制**：使用版本控制系统

#### 可维护性度量
1. **可理解性**：理解代码的难易程度
2. **可修改性**：修改代码的难易程度
3. **可测试性**：测试修改的难易程度

---

## 软件质量管理

### 软件质量模型

#### ISO/IEC 25010质量模型

##### 1. 功能性（Functional Suitability）
- **功能完整性**：功能覆盖所有指定任务
- **功能正确性**：提供正确的结果
- **功能适宜性**：功能有助于完成任务

##### 2. 性能效率（Performance Efficiency）
- **时间特性**：响应时间、处理时间
- **资源利用性**：CPU、内存、网络使用效率
- **容量**：系统容量上限

##### 3. 兼容性（Compatibility）
- **共存性**：与其他软件共存
- **互操作性**：与其他系统交换信息

##### 4. 易用性（Usability）
- **可识别性**：用户能识别软件适用性
- **可学习性**：用户学习使用的难易程度
- **可操作性**：用户操作和控制的难易程度
- **用户错误防护**：防止用户操作错误
- **用户界面美观性**：界面设计的美观程度
- **可访问性**：不同能力用户的可访问程度

##### 5. 可靠性（Reliability）
- **成熟性**：在正常操作下满足可靠性需求
- **可用性**：系统可操作和可访问的程度
- **容错性**：在硬件故障或软件错误下的运行能力
- **可恢复性**：在中断或失效后恢复数据的能力

##### 6. 安全性（Security）
- **保密性**：数据只能被授权访问
- **完整性**：防止未授权修改数据
- **不可否认性**：证明行为或事件已发生
- **可问责性**：追踪实体行为的能力
- **可认证性**：证明主体身份的能力

##### 7. 可维护性（Maintainability）
- **模块化**：系统由离散组件组成
- **可重用性**：资产可用于多个系统
- **可分析性**：评估修改影响的难易程度
- **可修改性**：修改而不引入缺陷的程度
- **可测试性**：建立测试准则的难易程度

##### 8. 可移植性（Portability）
- **适应性**：适应不同硬件、软件环境
- **可安装性**：在指定环境中安装的难易程度
- **可替换性**：替换其他软件的程度

#### 典型例题

**例题12：软件质量特性分析**
```
某在线教育系统需要满足以下要求，
分析每个要求对应的质量特性：

1. 系统能同时支持10000个用户在线学习
2. 用户界面简洁美观，操作直观
3. 系统7×24小时稳定运行，年宕机时间不超过4小时
4. 学生成绩数据不能被未授权人员访问
5. 系统能在Windows、Linux、macOS上运行
6. 新增课程功能时不影响现有功能

解答：

1. 性能效率 - 容量：系统需要支持大量并发用户

2. 易用性 - 用户界面美观性和可操作性：
   界面设计美观，操作简单直观

3. 可靠性 - 可用性：系统需要高可用性，
   年可用率 = (8760-4)/8760 = 99.95%

4. 安全性 - 保密性：保护学生隐私数据，
   防止未授权访问

5. 可移植性 - 适应性：系统需要跨平台运行，
   适应不同操作系统环境

6. 可维护性 - 可修改性：系统架构设计良好，
   新增功能不影响现有功能
```

### 软件质量保证

#### 质量保证活动
1. **质量计划**：制定质量目标和计划
2. **质量控制**：监控质量活动和结果
3. **质量改进**：持续改进质量过程

#### 质量保证方法
1. **技术评审**：同行评审、走查、审查
2. **测试**：各种测试方法和技术
3. **配置管理**：控制软件配置项
4. **度量分析**：收集和分析质量数据

### 软件过程改进

#### CMMI（能力成熟度模型集成）

##### 成熟度等级
1. **初始级（Initial）**：过程不可预测，反应式
2. **已管理级（Managed）**：项目级别的过程管理
3. **已定义级（Defined）**：组织级别的过程标准化
4. **定量管理级（Quantitatively Managed）**：过程的定量控制
5. **优化级（Optimizing）**：持续过程改进

##### 关键过程域（KPA）
- **需求管理**：管理需求变更
- **项目计划**：制定项目计划
- **项目跟踪**：监控项目进展
- **配置管理**：控制配置项
- **质量保证**：确保过程质量

#### 典型例题

**例题13：CMMI等级评估**
```
某软件公司的现状：
- 项目成功主要依赖个人能力
- 没有标准的开发流程
- 项目计划经常变更
- 质量主要靠测试保证
- 很少进行过程改进

该公司目前处于CMMI哪个等级？要达到下一等级需要改进什么？

解答：

当前等级：初始级（Level 1）
特征分析：
- 依赖个人能力 → 过程不可预测
- 没有标准流程 → 过程临时性
- 计划经常变更 → 项目管理混乱
- 质量靠测试 → 缺乏过程质量保证

要达到已管理级（Level 2）需要改进：

1. 建立项目管理过程：
   - 制定项目计划并跟踪执行
   - 建立需求管理流程
   - 实施配置管理

2. 建立基本的质量保证：
   - 制定质量计划
   - 实施同行评审
   - 建立测试流程

3. 建立度量和分析：
   - 收集项目数据
   - 分析项目绩效
   - 建立基线

4. 培训和能力建设：
   - 培训项目管理技能
   - 建立过程文档
   - 推广最佳实践
```

---

## 软件项目管理

### 项目管理基础

#### 项目特征
1. **临时性**：有明确的开始和结束时间
2. **独特性**：产生独特的产品或服务
3. **渐进明细**：随着项目进展逐步明确细节

#### 项目管理知识域
1. **范围管理**：定义和控制项目范围
2. **时间管理**：确保项目按时完成
3. **成本管理**：控制项目成本
4. **质量管理**：确保项目质量
5. **人力资源管理**：管理项目团队
6. **沟通管理**：确保信息有效传递
7. **风险管理**：识别和应对项目风险
8. **采购管理**：管理项目采购活动

### 项目计划

#### 工作分解结构（WBS）
**定义**：将项目可交付成果和项目工作分解为更小、更易管理的组件

**分解原则**：
- 100%规则：下级任务完全覆盖上级任务
- 相互独立：同级任务相互独立
- 适当粒度：分解到可管理的程度

#### 活动排序
**方法**：
1. **紧前关系绘图法（PDM）**：使用节点表示活动
2. **箭线图法（ADM）**：使用箭线表示活动

**依赖关系**：
- **完成-开始（FS）**：前置活动完成后，后续活动才能开始
- **开始-开始（SS）**：前置活动开始后，后续活动才能开始
- **完成-完成（FF）**：前置活动完成后，后续活动才能完成
- **开始-完成（SF）**：前置活动开始后，后续活动才能完成

#### 关键路径法（CPM）
**基本概念**：
- **关键路径**：项目中最长的活动路径
- **关键活动**：关键路径上的活动
- **总浮动时间**：活动可以延迟而不影响项目完成时间
- **自由浮动时间**：活动可以延迟而不影响后续活动

**计算步骤**：
1. **正向计算**：计算最早开始时间（ES）和最早完成时间（EF）
2. **反向计算**：计算最晚开始时间（LS）和最晚完成时间（LF）
3. **计算浮动时间**：总浮动时间 = LS - ES = LF - EF

#### 典型例题

**例题14：关键路径计算**
```
某项目的活动信息如下：
活动  持续时间  紧前活动
A     3        -
B     4        -
C     2        A
D     5        A,B
E     3        C
F     4        D,E

绘制网络图并计算关键路径。

解答：

网络图：
A(3) → C(2) → E(3) → F(4)
B(4) → D(5) → F(4)

正向计算：
A: ES=0, EF=3
B: ES=0, EF=4
C: ES=3, EF=5
D: ES=4, EF=9 (等待A和B都完成)
E: ES=5, EF=8
F: ES=9, EF=13 (等待D和E都完成)

反向计算（从项目结束时间13开始）：
F: LS=9, LF=13
E: LS=6, LF=9 (F的LS - F的持续时间)
D: LS=4, LF=9
C: LS=3, LF=5
A: LS=0, LF=3
B: LS=0, LF=4

浮动时间计算：
A: 0-0=0 (关键活动)
B: 0-0=0 (关键活动)  
C: 3-3=0 (关键活动)
D: 4-4=0 (关键活动)
E: 6-5=1
F: 9-9=0 (关键活动)

关键路径：A→C→D→F 或 B→D→F
项目工期：13天
```

### 项目控制

#### 挣值管理（EVM）
**基本参数**：
- **计划价值（PV）**：计划完成工作的预算成本
- **挣值（EV）**：已完成工作的预算成本
- **实际成本（AC）**：已完成工作的实际成本

**绩效指标**：
- **成本偏差（CV）**：CV = EV - AC
- **进度偏差（SV）**：SV = EV - PV
- **成本绩效指数（CPI）**：CPI = EV / AC
- **进度绩效指数（SPI）**：SPI = EV / PV

**预测指标**：
- **完工估算（EAC）**：EAC = BAC / CPI
- **完工尚需估算（ETC）**：ETC = EAC - AC

#### 典型例题

**例题15：挣值分析**
```
某项目执行到第6个月，相关数据如下：
- 项目总预算（BAC）：100万元
- 计划完成60%的工作
- 实际完成50%的工作  
- 实际花费65万元

计算项目的绩效指标并分析项目状态。

解答：

基本参数：
PV = 100 × 60% = 60万元
EV = 100 × 50% = 50万元
AC = 65万元

绩效指标：
CV = EV - AC = 50 - 65 = -15万元 (成本超支)
SV = EV - PV = 50 - 60 = -10万元 (进度滞后)
CPI = EV / AC = 50 / 65 = 0.77 (成本效率低)
SPI = EV / PV = 50 / 60 = 0.83 (进度效率低)

预测指标：
EAC = BAC / CPI = 100 / 0.77 = 130万元
ETC = EAC - AC = 130 - 65 = 65万元

项目状态分析：
1. 成本超支：已超支15万元，成本效率只有77%
2. 进度滞后：落后计划10万元工作量，进度效率83%
3. 完工预测：预计总成本130万元，超出预算30万元
4. 需要采取纠正措施控制成本和加快进度
```

### 风险管理

#### 风险管理过程
1. **风险识别**：识别项目风险
2. **风险分析**：评估风险概率和影响
3. **风险应对**：制定风险应对策略
4. **风险监控**：跟踪风险状态

#### 风险应对策略
1. **规避**：消除风险或其影响
2. **转移**：将风险转移给第三方
3. **减轻**：降低风险概率或影响
4. **接受**：接受风险及其后果

#### 典型例题

**例题16：风险管理**
```
某软件项目面临以下风险，制定相应的应对策略：

1. 关键开发人员可能离职（概率：中，影响：高）
2. 客户需求可能发生重大变更（概率：高，影响：中）
3. 第三方组件可能不稳定（概率：低，影响：高）
4. 服务器硬件可能故障（概率：低，影响：中）

解答：

风险应对策略：

1. 关键人员离职风险：
   策略：减轻
   措施：
   - 建立知识共享机制，避免关键知识集中
   - 培养备用人员，建立技能冗余
   - 改善工作环境，提高员工满意度
   - 制定知识转移计划

2. 需求变更风险：
   策略：减轻 + 接受
   措施：
   - 建立需求变更控制流程
   - 采用敏捷开发方法，适应变更
   - 与客户签署变更管理协议
   - 预留变更缓冲时间和预算

3. 第三方组件不稳定：
   策略：规避 + 转移
   措施：
   - 选择成熟稳定的组件
   - 准备备选方案
   - 要求供应商提供技术支持保证
   - 购买相关保险

4. 服务器硬件故障：
   策略：转移 + 减轻
   措施：
   - 使用云服务，转移硬件风险
   - 建立硬件冗余和备份
   - 制定故障恢复计划
   - 购买硬件维护服务
```

---

## 学习建议

### 重点掌握
1. **开发模型**：各种开发模型的特点、优缺点和适用场景
2. **需求分析**：需求获取方法、分析技术、文档编写
3. **软件设计**：设计原则、设计模式、架构设计
4. **软件测试**：测试方法、测试策略、测试管理
5. **项目管理**：项目计划、进度控制、风险管理

### 解题技巧
1. **模型选择**：根据项目特点选择合适的开发模型
2. **测试设计**：掌握各种测试用例设计方法
3. **质量分析**：理解软件质量模型和评价方法
4. **项目计算**：熟练掌握关键路径、挣值分析等计算

### 常考题型
1. **开发模型比较**：分析不同模型的适用场景
2. **需求分析技术**：DFD绘制、用例图设计
3. **测试用例设计**：等价类划分、边界值分析
4. **设计模式应用**：识别和应用常见设计模式
5. **项目管理计算**：关键路径、挣值管理计算

### 实践建议
1. **项目经验**：参与实际软件项目，体验开发过程
2. **工具使用**：熟悉项目管理工具、测试工具
3. **案例分析**：分析成功和失败的软件项目案例
4. **持续学习**：关注软件工程新技术和最佳实践

---

*本文档涵盖软件设计师考试中软件工程的所有重要知识点，建议结合实际项目经验学习使用。*