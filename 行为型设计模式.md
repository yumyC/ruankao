# 行为型设计模式学习笔记

本文档整理了常见的 11 种行为型设计模式，包括概念、英文名称、适用场景、UML 结构、代码示例及关键点，方便阅读与复习。

---

## 1. 观察者模式（Observer）

**概念**：定义对象间的一对多依赖，当一个对象状态变化时，所有依赖者都会收到通知并自动更新。

**英文名称**：Observer

**应用场景**：
- 发布/订阅系统，如微信公众号与粉丝关系
- 数据变化通知

**UML 结构**：
- Subject（被观察者/主体）
  - attach(observer)
  - detach(observer)
  - notify()
- Observer（观察者）
  - update(subject)

**Python 示例**：
    class Subject:
        def __init__(self):
            self._observers = []
            self._state = None

        def attach(self, observer):
            self._observers.append(observer)

        def detach(self, observer):
            self._observers.remove(observer)

        def notify(self):
            for observer in self._observers:
                observer.update(self)

        @property
        def state(self):
            return self._state

        @state.setter
        def state(self, value):
            self._state = value
            self.notify()

    class Observer:
        def update(self, subject):
            pass

    class Fan(Observer):
        def update(self, subject):
            print(f"收到更新：{subject.state}")

**总结**：
- 一对多依赖关系
- 主体状态变化时通知观察者
- 支持动态添加观察者

---

## 2. 访问器模式（Visitor）

**概念**：表示一个作用于对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。

**英文名称**：Visitor

**应用场景**：
- 超市商品打折策略
- 对象结构稳定，但需要对不同对象执行不同操作

**UML 结构**：
- Element（元素）
  - accept(visitor)
- ConcreteElement（具体元素，如葡萄、香蕉）
- Visitor（访问器）
  - visitConcreteElementA
  - visitConcreteElementB

**Python 示例**：
    class Element:
        def accept(self, visitor):
            visitor.visit(self)

    class Grape(Element):
        def __init__(self, price):
            self.price = price

    class Banana(Element):
        def __init__(self, price):
            self.price = price

    class Visitor:
        def visit(self, element):
            if isinstance(element, Grape):
                print(f"葡萄价格策略：{element.price * 0.9}")
            elif isinstance(element, Banana):
                print(f"香蕉价格策略：{element.price * 0.8}")

    items = [Grape(10), Banana(20)]
    visitor = Visitor()
    for item in items:
        item.accept(visitor)

**总结**：
- 支持新操作的添加而不改变对象结构
- 使用 `accept` 方法传入访问器
- 符合开放封闭原则

---

## 3. 状态模式（State）

**概念**：允许对象在内部状态改变时改变其行为。

**英文名称**：State

**应用场景**：
- 交通灯
- 自动售货机状态控制

**UML 结构**：
- Context（上下文）
  - state
  - request()
- State（状态接口）
  - handle()
- ConcreteState（具体状态，如红灯、绿灯）

**Python 示例**：
    class State:
        def handle(self):
            pass

    class Red(State):
        def handle(self):
            print("红灯停")

    class Green(State):
        def handle(self):
            print("绿灯行")

    class TrafficLight:
        def __init__(self, state):
            self.state = state

        def change(self, state):
            self.state = state

        def request(self):
            self.state.handle()

**总结**：
- 不同状态有不同行为
- 支持状态切换而不改变主体代码

---

## 4. 职责链模式（Chain of Responsibility）

**概念**：避免请求发送者和接收者耦合，使多个对象都有机会处理请求，将这些对象连成一条链。

**英文名称**：Chain of Responsibility

**应用场景**：
- 请求多步骤处理
- 前端请求经过多种验证（如安全、权限、编码处理）

**Python 示例**：
    class Handler:
        def __init__(self, successor=None):
            self.successor = successor

        def handle(self, request):
            handled = self._handle(request)
            if not handled and self.successor:
                self.successor.handle(request)

        def _handle(self, request):
            raise NotImplementedError()

    class AuthHandler(Handler):
        def _handle(self, request):
            if request == "auth":
                print("权限验证")
                return True
            return False

    class LogHandler(Handler):
        def _handle(self, request):
            if request == "log":
                print("日志记录")
                return True
            return False

    handler_chain = AuthHandler(LogHandler())
    handler_chain.handle("log")

**总结**：
- 解耦发送者与接收者
- 请求沿链传递直到处理

---

## 5. 命令模式（Command）

**概念**：将请求封装为对象，从而使用不同的请求对客户进行参数化。

**英文名称**：Command

**应用场景**：
- 遥控器按钮操作
- 事务日志记录、操作回退

**Python 示例**：
    class Command:
        def execute(self):
            pass

    class Light:
        def on(self):
            print("开灯")

        def off(self):
            print("关灯")

    class LightOnCommand(Command):
        def __init__(self, light):
            self.light = light
        def execute(self):
            self.light.on()

    class RemoteControl:
        def __init__(self):
            self.slot = None
        def set_command(self, command):
            self.slot = command
        def press(self):
            self.slot.execute()

**总结**：
- 请求封装为对象
- 支持参数化、撤销、排队、日志

---

## 6. 解释器模式（Interpreter）

**概念**：给定一种语言，定义它的文法表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

**英文名称**：Interpreter

**应用场景**：
- SQL、正则表达式解析
- 自定义小型脚本语言

**Python 示例**：
    class Expression:
        def interpret(self, context):
            pass

    class TerminalExpression(Expression):
        def interpret(self, context):
            return context in ["A", "B"]

    class NonTerminalExpression(Expression):
        def __init__(self, expr1, expr2):
            self.expr1 = expr1
            self.expr2 = expr2

        def interpret(self, context):
            return self.expr1.interpret(context) and self.expr2.interpret(context)

**总结**：
- 通过抽象语法树处理语言
- 可扩展复杂表达式计算

---

## 7. 迭代器模式（Iterator）

**概念**：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。

**英文名称**：Iterator

**应用场景**：
- 容器对象遍历
- 统一不同集合操作接口

**Python 示例**：
    class Iterator:
        def __init__(self, collection):
            self.collection = collection
            self.index = 0

        def has_next(self):
            return self.index < len(self.collection)

        def next(self):
            if self.has_next():
                item = self.collection[self.index]
                self.index += 1
                return item
            return None

**总结**：
- 遍历方法统一
- 不暴露内部结构

---

## 8. 中介者模式（Mediator）

**概念**：用一个中介对象封装一系列对象的交互，使对象之间不需要显式地相互引用，从而降低耦合。

**英文名称**：Mediator

**应用场景**：
- 租房中介
- 飞行控制塔协调飞机

**Python 示例**：
    class Mediator:
        def notify(self, sender, event):
            pass

    class ConcreteMediator(Mediator):
        def __init__(self, customer, landlord):
            self.customer = customer
            self.landlord = landlord

        def notify(self, sender, event):
            if event == "rent_request":
                print("中介转发租房请求")

**总结**：
- 降低对象间耦合
- 中介控制对象间交互

---

## 9. 备忘录模式（Memento）

**概念**：在不破坏封装性的前提下，捕获对象的内部状态，并在未来将对象恢复到这个状态。

**英文名称**：Memento

**应用场景**：
- 文本编辑器撤销
- 游戏存档

**Python 示例**：
    class Memento:
        def __init__(self, state):
            self.state = state

    class Originator:
        def __init__(self):
            self.state = None

        def create_memento(self):
            return Memento(self.state)

        def restore(self, memento):
            self.state = memento.state

**总结**：
- 保存历史状态
- 支持恢复

---

## 10. 策略模式（Strategy）

**概念**：定义一系列算法，将每个算法封装起来，并使它们可以互换。

**英文名称**：Strategy

**应用场景**：
- 不同计算方式，如不同年龄段计算成绩
- 打折策略、路径规划

**Python 示例**：
    class Strategy:
        def calculate(self, data):
            pass

    class StudentStrategy(Strategy):
        def calculate(self, n):
            return sum(range(1, n+1))

    class MiddleStudentStrategy(Strategy):
        def calculate(self, n):
            return n*(n+1)//2

    class Context:
        def __init__(self, strategy):
            self.strategy = strategy

        def execute(self, n):
            return self.strategy.calculate(n)

**总结**：
- 算法封装，可替换
- 遵循开放封闭原则

---

## 11. 模板方法模式（Template Method）

**概念**：定义一个操作的算法骨架，将部分步骤延迟到子类中实现。

**英文名称**：Template Method

**应用场景**：
- 工作流程、步骤固定的业务逻辑
- 提供固定流程的灵活实现

**Python 示例**：
    class Template:
        def step1(self): pass
        def step2(self): pass
        def step3(self): pass

        def execute(self):
            self.step1()
            self.step2()
            self.step3()

    class ConcreteTemplate(Template):
        def step1(self): print("步骤1")
        def step2(self): print("步骤2")
        def step3(self): print("步骤3")

**总结**：
- 算法骨架固定
- 子类可重写具体步骤
- 保证流程顺序不变

---

## 行为型设计模式汇总表

| 模式 | 英文 | 主要用途 | 核心对象 |
|------|------|----------|----------|
| 观察者 | Observer | 数据变化通知 | Subject, Observer |
| 访问器 | Visitor | 对象操作扩展 | Element, Visitor |
| 状态 | State | 状态改变行为 | Context, State |
| 职责链 | Chain of Responsibility | 请求处理链 | Handler |
| 命令 | Command | 封装请求 | Command, Receiver |
| 解释器 | Interpreter | 语言解释 | Expression |
| 迭代器 | Iterator | 容器遍历 | Iterator, Aggregate |
| 中介者 | Mediator | 降低对象耦合 | Mediator, Colleague |
| 备忘录 | Memento | 状态保存恢复 | Originator, Memento |
| 策略 | Strategy | 算法封装替换 | Strategy, Context |
| 模板方法 | Template Method | 固定流程可扩展 | Template |

---

## 行为型模式总结

- **对象型**：观察者、状态、策略、命令、职责链、中介者、备忘录、迭代器、访问器
- **类型**：模板方法、解释器
- **核心思想**：
  - 封装行为或算法
  - 降低耦合
  - 增强系统灵活性与可扩展性
# 行为型设计模式学习笔记

本文档整理了常见的 11 种行为型设计模式，包括概念、英文名称、适用场景、UML 结构、代码示例及关键点，方便阅读与复习。

---

## 1. 观察者模式（Observer）

**概念**：定义对象间的一对多依赖，当一个对象状态变化时，所有依赖者都会收到通知并自动更新。

**英文名称**：Observer

**应用场景**：
- 发布/订阅系统，如微信公众号与粉丝关系
- 数据变化通知

**UML 结构**：
- Subject（被观察者/主体）
  - attach(observer)
  - detach(observer)
  - notify()
- Observer（观察者）
  - update(subject)

**Python 示例**：
    class Subject:
        def __init__(self):
            self._observers = []
            self._state = None

        def attach(self, observer):
            self._observers.append(observer)

        def detach(self, observer):
            self._observers.remove(observer)

        def notify(self):
            for observer in self._observers:
                observer.update(self)

        @property
        def state(self):
            return self._state

        @state.setter
        def state(self, value):
            self._state = value
            self.notify()

    class Observer:
        def update(self, subject):
            pass

    class Fan(Observer):
        def update(self, subject):
            print(f"收到更新：{subject.state}")

**总结**：
- 一对多依赖关系
- 主体状态变化时通知观察者
- 支持动态添加观察者

---

## 2. 访问器模式（Visitor）

**概念**：表示一个作用于对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。

**英文名称**：Visitor

**应用场景**：
- 超市商品打折策略
- 对象结构稳定，但需要对不同对象执行不同操作

**UML 结构**：
- Element（元素）
  - accept(visitor)
- ConcreteElement（具体元素，如葡萄、香蕉）
- Visitor（访问器）
  - visitConcreteElementA
  - visitConcreteElementB

**Python 示例**：
    class Element:
        def accept(self, visitor):
            visitor.visit(self)

    class Grape(Element):
        def __init__(self, price):
            self.price = price

    class Banana(Element):
        def __init__(self, price):
            self.price = price

    class Visitor:
        def visit(self, element):
            if isinstance(element, Grape):
                print(f"葡萄价格策略：{element.price * 0.9}")
            elif isinstance(element, Banana):
                print(f"香蕉价格策略：{element.price * 0.8}")

    items = [Grape(10), Banana(20)]
    visitor = Visitor()
    for item in items:
        item.accept(visitor)

**总结**：
- 支持新操作的添加而不改变对象结构
- 使用 `accept` 方法传入访问器
- 符合开放封闭原则

---

## 3. 状态模式（State）

**概念**：允许对象在内部状态改变时改变其行为。

**英文名称**：State

**应用场景**：
- 交通灯
- 自动售货机状态控制

**UML 结构**：
- Context（上下文）
  - state
  - request()
- State（状态接口）
  - handle()
- ConcreteState（具体状态，如红灯、绿灯）

**Python 示例**：
    class State:
        def handle(self):
            pass

    class Red(State):
        def handle(self):
            print("红灯停")

    class Green(State):
        def handle(self):
            print("绿灯行")

    class TrafficLight:
        def __init__(self, state):
            self.state = state

        def change(self, state):
            self.state = state

        def request(self):
            self.state.handle()

**总结**：
- 不同状态有不同行为
- 支持状态切换而不改变主体代码

---

## 4. 职责链模式（Chain of Responsibility）

**概念**：避免请求发送者和接收者耦合，使多个对象都有机会处理请求，将这些对象连成一条链。

**英文名称**：Chain of Responsibility

**应用场景**：
- 请求多步骤处理
- 前端请求经过多种验证（如安全、权限、编码处理）

**Python 示例**：
    class Handler:
        def __init__(self, successor=None):
            self.successor = successor

        def handle(self, request):
            handled = self._handle(request)
            if not handled and self.successor:
                self.successor.handle(request)

        def _handle(self, request):
            raise NotImplementedError()

    class AuthHandler(Handler):
        def _handle(self, request):
            if request == "auth":
                print("权限验证")
                return True
            return False

    class LogHandler(Handler):
        def _handle(self, request):
            if request == "log":
                print("日志记录")
                return True
            return False

    handler_chain = AuthHandler(LogHandler())
    handler_chain.handle("log")

**总结**：
- 解耦发送者与接收者
- 请求沿链传递直到处理

---

## 5. 命令模式（Command）

**概念**：将请求封装为对象，从而使用不同的请求对客户进行参数化。

**英文名称**：Command

**应用场景**：
- 遥控器按钮操作
- 事务日志记录、操作回退

**Python 示例**：
    class Command:
        def execute(self):
            pass

    class Light:
        def on(self):
            print("开灯")

        def off(self):
            print("关灯")

    class LightOnCommand(Command):
        def __init__(self, light):
            self.light = light
        def execute(self):
            self.light.on()

    class RemoteControl:
        def __init__(self):
            self.slot = None
        def set_command(self, command):
            self.slot = command
        def press(self):
            self.slot.execute()

**总结**：
- 请求封装为对象
- 支持参数化、撤销、排队、日志

---

## 6. 解释器模式（Interpreter）

**概念**：给定一种语言，定义它的文法表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

**英文名称**：Interpreter

**应用场景**：
- SQL、正则表达式解析
- 自定义小型脚本语言

**Python 示例**：
    class Expression:
        def interpret(self, context):
            pass

    class TerminalExpression(Expression):
        def interpret(self, context):
            return context in ["A", "B"]

    class NonTerminalExpression(Expression):
        def __init__(self, expr1, expr2):
            self.expr1 = expr1
            self.expr2 = expr2

        def interpret(self, context):
            return self.expr1.interpret(context) and self.expr2.interpret(context)

**总结**：
- 通过抽象语法树处理语言
- 可扩展复杂表达式计算

---

## 7. 迭代器模式（Iterator）

**概念**：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。

**英文名称**：Iterator

**应用场景**：
- 容器对象遍历
- 统一不同集合操作接口

**Python 示例**：
    class Iterator:
        def __init__(self, collection):
            self.collection = collection
            self.index = 0

        def has_next(self):
            return self.index < len(self.collection)

        def next(self):
            if self.has_next():
                item = self.collection[self.index]
                self.index += 1
                return item
            return None

**总结**：
- 遍历方法统一
- 不暴露内部结构

---

## 8. 中介者模式（Mediator）

**概念**：用一个中介对象封装一系列对象的交互，使对象之间不需要显式地相互引用，从而降低耦合。

**英文名称**：Mediator

**应用场景**：
- 租房中介
- 飞行控制塔协调飞机

**Python 示例**：
    class Mediator:
        def notify(self, sender, event):
            pass

    class ConcreteMediator(Mediator):
        def __init__(self, customer, landlord):
            self.customer = customer
            self.landlord = landlord

        def notify(self, sender, event):
            if event == "rent_request":
                print("中介转发租房请求")

**总结**：
- 降低对象间耦合
- 中介控制对象间交互

---

## 9. 备忘录模式（Memento）

**概念**：在不破坏封装性的前提下，捕获对象的内部状态，并在未来将对象恢复到这个状态。

**英文名称**：Memento

**应用场景**：
- 文本编辑器撤销
- 游戏存档

**Python 示例**：
    class Memento:
        def __init__(self, state):
            self.state = state

    class Originator:
        def __init__(self):
            self.state = None

        def create_memento(self):
            return Memento(self.state)

        def restore(self, memento):
            self.state = memento.state

**总结**：
- 保存历史状态
- 支持恢复

---

## 10. 策略模式（Strategy）

**概念**：定义一系列算法，将每个算法封装起来，并使它们可以互换。

**英文名称**：Strategy

**应用场景**：
- 不同计算方式，如不同年龄段计算成绩
- 打折策略、路径规划

**Python 示例**：
    class Strategy:
        def calculate(self, data):
            pass

    class StudentStrategy(Strategy):
        def calculate(self, n):
            return sum(range(1, n+1))

    class MiddleStudentStrategy(Strategy):
        def calculate(self, n):
            return n*(n+1)//2

    class Context:
        def __init__(self, strategy):
            self.strategy = strategy

        def execute(self, n):
            return self.strategy.calculate(n)

**总结**：
- 算法封装，可替换
- 遵循开放封闭原则

---

## 11. 模板方法模式（Template Method）

**概念**：定义一个操作的算法骨架，将部分步骤延迟到子类中实现。

**英文名称**：Template Method

**应用场景**：
- 工作流程、步骤固定的业务逻辑
- 提供固定流程的灵活实现

**Python 示例**：
    class Template:
        def step1(self): pass
        def step2(self): pass
        def step3(self): pass

        def execute(self):
            self.step1()
            self.step2()
            self.step3()

    class ConcreteTemplate(Template):
        def step1(self): print("步骤1")
        def step2(self): print("步骤2")
        def step3(self): print("步骤3")

**总结**：
- 算法骨架固定
- 子类可重写具体步骤
- 保证流程顺序不变

---

## 行为型设计模式汇总表

| 模式 | 英文 | 主要用途 | 核心对象 |
|------|------|----------|----------|
| 观察者 | Observer | 数据变化通知 | Subject, Observer |
| 访问器 | Visitor | 对象操作扩展 | Element, Visitor |
| 状态 | State | 状态改变行为 | Context, State |
| 职责链 | Chain of Responsibility | 请求处理链 | Handler |
| 命令 | Command | 封装请求 | Command, Receiver |
| 解释器 | Interpreter | 语言解释 | Expression |
| 迭代器 | Iterator | 容器遍历 | Iterator, Aggregate |
| 中介者 | Mediator | 降低对象耦合 | Mediator, Colleague |
| 备忘录 | Memento | 状态保存恢复 | Originator, Memento |
| 策略 | Strategy | 算法封装替换 | Strategy, Context |
| 模板方法 | Template Method | 固定流程可扩展 | Template |

---

## 行为型模式总结

- **对象型**：观察者、状态、策略、命令、职责链、中介者、备忘录、迭代器、访问器
- **类型**：模板方法、解释器
- **核心思想**：
  - 封装行为或算法
  - 降低耦合
  - 增强系统灵活性与可扩展性
