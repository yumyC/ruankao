# 查找算法总结

---

## 1️⃣ 顺序查找（Sequential Search）

- **概念**：从第一个元素开始，依次比较，直到找到目标元素或者到达末尾。
- **过程示例**：
    给定元素 X，在数组中依次比较：
    第1个 -> 第2个 -> 第3个 ... -> 最后一个
- **平均查找长度**：
    - 总次数 = 首项 + 尾项 × 项数 ÷ 2
    - 平均查找长度 = 总次数 ÷ N = (N + 1) / 2
- **时间复杂度**：
    - 去掉常数，顺序查找时间复杂度为 O(N)

---

## 2️⃣ 二分查找（Binary Search）

- **概念**：对有序数组，通过不断折半缩小查找范围。
- **前提条件**：
    1. 数据必须有序
    2. 数据存储在数组（顺序表）中

- **查找过程示例**：
    数组：1 2 3 4 5 6 7 8 9 10 11 12
    查找元素 17：
    1. 定义两个指针：low = 起始，high = 结尾
    2. middle = floor((low + high)/2)
    3. 如果目标 < arr[middle] → high = middle - 1
       如果目标 > arr[middle] → low = middle + 1
       如果目标 = arr[middle] → 找到
    4. 重复步骤 2-3 直到 low > high 或找到元素

- **效率分析**：
    - 平均比较次数 ≈ log₂N
    - 时间复杂度：O(log N)
    - 成功查找最多比较次数：log₂N + 1
    - 查找失败平均次数：N + 1（可以通过案例计算）

- **注意事项**：
    - 比较操作用 `if` 判断，不是循环
    - 查找失败时，最后 low > high 即停止

---

## 3️⃣ 哈希查找（Hash Search / 散列查找）

- **概念**：通过散列函数将元素映射到数组的索引位置，提高查找效率。
- **基本思想**：
    1. 使用散列函数将元素映射到数组下标
    2. 相同散列值的元素放在同一组
    3. 查找时只访问对应组，减少比较次数

- **示例**：
    原始数据：3, 8, 8, 12, 17, 9  
    散列函数：key % 5
    - 3 % 5 = 3 → 放在下标 3
    - 8 % 5 = 3 → 放在下标 3 的下一位置
    - 12 % 5 = 2 → 放在下标 2
    - 17 % 5 = 2 → 放在下标 2 的下一位置
    - 9 % 5 = 4 → 放在下标 4

- **冲突处理**：
    - 相同元素不算冲突，只存一个
    - 不同元素映射到相同位置 → 冲突
    - 线性探测法：冲突发生时往下一个空格存放

- **查找效率**：
    - 直接通过散列值找到元素所在组
    - 对组内元素再进行线性查找
    - 在一定程度上提高查找效率

- **题目应用**：
    - 哈希表存储元素，冲突处理主要针对不同元素映射到同一位置
    - 相同元素只保留一个，不算冲突

---

## ✅ 总结

| 查找算法 | 前提条件 | 平均/最坏比较次数 | 时间复杂度 | 特点 |
|-----------|-----------|----------------|------------|------|
| 顺序查找 | 无序或有序 | (N+1)/2 / N | O(N) | 简单，适合小数据量 |
| 二分查找 | 有序数组 | log₂N | O(log N) | 高效，数组必须有序 |
| 哈希查找 | 无序数据 + 散列函数 | O(1) 平均 | O(1) 平均 | 查找快，但需要额外空间处理冲突 |

