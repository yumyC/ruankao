# 算法复杂度总结

---

## 1️⃣ 空间复杂度（Space Complexity）

**概念**：算法执行过程中 **额外占用的存储空间**。

- **例子 1：高斯求和**
    sum = n * (n + 1) / 2
  - 只用到了一个变量 `sum`，所以空间复杂度 **O(1)**。

- **例子 2：循环求和**
    sum = 0
    for i in range(1, n+1):
        sum += i
  - 使用了变量 `i` 和 `sum`，空间占用和 `n` 无关，所以空间复杂度 **O(1)**。
  - 注意：如果每次循环创建额外数组或存储所有中间结果，空间复杂度就会随 `n` 增长。

✅ **结论**：空间复杂度关注 **额外变量、数组、栈等**，不关注输入本身的大小。

---

## 2️⃣ 时间复杂度（Time Complexity）

**概念**：算法执行操作的次数，**不是真实耗时**，而是用 **渐进操作次数** 衡量增长速度。

- **精确时间复杂度**：计算每个操作次数（一般很复杂）。
- **渐进时间复杂度**：只关注 **最大的影响因素**，去掉常量。

### 常见例子：
| 时间复杂度 | 例子 |
|------------|------|
| O(1) | 单次操作 |
| O(N) | 单层循环 for i in range(n) |
| O(N²) | 双层循环 for i in range(n): for j in range(n) |
| O(log N) | 二分查找 |
| O(N log N) | 堆排序、归并排序 |
| O(2^N) | 蛮力子序列搜索 |
| O(N!) | 全排列问题 |

---

## 3️⃣ 经典算法案例

1. **单层循环**：O(N)  
    for i in range(n):
        do_something()

2. **双层循环**：O(N²)  
    for i in range(n):
        for j in range(n):
            do_something()

3. **二分查找**：O(log N)  
  - 每次操作把搜索空间减半。

4. **堆排序**：O(N log N)  
  - 每次调整堆的操作需要 log N 次，总共 N 次操作。

5. **最长公共子序列（LCS）蛮力法**：
  - 对长度为 N 的两个字符串：
    - 子序列数量 = 2^N
    - 检查每个子序列最多需要 N 次操作
  - **时间复杂度** = O(N * 2^N)

6. **动态规划法 LCS**：
  - 创建二维数组 dp[N][N]  
  - 双层循环填表，每次操作为 O(1)
  - **时间复杂度** = O(N²)
  - **空间复杂度** = O(N²)（可优化到 O(N)）

---

## 4️⃣ 关于最大公共子序列（LCS）

- **子序列 vs 子串**：
  - 子序列可以不连续，但顺序必须保持。
- **蛮力法**：
  - 枚举所有子序列 → 2^N 个
  - 检查每个子序列 → 每个最多 N 步  
  → **总复杂度 O(N * 2^N)**
- **动态规划**：
  - 使用最优子结构：dp[i][j] 表示 X[0..i] 和 Y[0..j] 的 LCS
  - 双层循环填表 → O(N²)

💡 **注意**：max() 只是一个比较操作，不是循环，不要误认为增加了循环层数。

---

## 5️⃣ 总结复杂度大小关系（渐进增长）

O(1) < O(log N) < O(N) < O(N log N) < O(N²) < O(N^3) < O(2^N) < O(N!)

- 常量和低阶项可以忽略。
- 高阶项决定增长速度。
